---
title: "Quantitative genetics results - transient dynamics"
author: "Lucas A. Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
output:
  github_document:
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png",
  fig.width = 6,
  fig.height = 4,
  echo = TRUE,
  eval = TRUE
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```

```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
```

```{r load-libs}
suppressPackageStartupMessages({
    library(tidyverse)
    library(sauron)
    library(cowplot)
})
```



This document explores changes in traits and abundances through time,
specifically over the period as the final lineage sets are determined.
The main question I'm trying to address here is whether the majority of 
trait changes typically occur before or after lineages go extinct.


## Needed functions

```{r needed-funs}
# Function to get the relevant rds file for a given simulation scenario:
get_sim <- function(eta_sign, d_sign, q) {
    fn <- sprintf("results/quant_gen/q%i/eta=%s__d=%s.rds", q, eta_sign, d_sign)
    return(readRDS(fn))
}
# Are two sets of traits the same?
V_same <- function(Vs, precision) {
    V1 <- Vs[[1]]
    V2 <- Vs[[2]]
    if (length(V1) != length(V2)) return(FALSE)
    return(all((V1 - V2)^2 < precision^2))
}
# Are two sets of abundances the same?
N_same <- function(Ns, precision) {
    N1 <- Ns[[1]]
    N2 <- Ns[[2]]
    if (length(N1) != length(N2)) return(FALSE)
    return(all((N1 - N2)^2 < precision^2))
}
# Same but for a `quant_gen` object containing multiple reps, and checking
# whether a specified time point is different from the last one:
check_diff <- function(qg_obj, time1, precision = 1e-4) {
    time1 <- min(qg_obj$nv$time[qg_obj$nv$time > time1])
    time2 <- max(qg_obj$nv$time)
    # Filtered data frame:
    fdf <- qg_obj$nv %>%
        filter(time == time1 | time == time2) %>%
        arrange(rep, time, spp, trait) %>%
        group_by(rep, time, spp) %>%
        summarize(N = N[[1]],
                  V = list(value)) %>%
        group_by(rep, time) %>%
        summarize(N = list(N),
                  V = list(do.call(rbind, V))) %>%
        ungroup()
    
    fdf %>% 
        group_by(rep) %>% 
        summarize(V_s = V_same(V, precision),
                  N_s = N_same(N, precision)) %>% 
        summarize_at(vars(V_s, N_s), sum)
}
```



## Are equilibriums reached?

When $d \le 0$, everything stays the same after time point 10,001.
When $d > 0$ , this happens at $8 \times 10^6 + 1$ for traits and $19.9 \times 10^6 + 1$
for abundances.
The code below confirms this:

```{r check_equil}
# Returns a `1` if the simulation scenario deviates
# from what I mention above:
check_scenarios <- function(.q, .e, .d) {
    qg <- get_sim(.e, .d, .q)
    if (.d > 0) {
        y <- unlist(check_diff(qg, 19.9e6))
        z <- unlist(check_diff(qg, 8e6))
        if (any(y != 100) || z[["V_s"]] != 100) return(1)
    } else {
        z <- unlist(check_diff(qg, 10e3))
        if (any(z != 100)) return(1)
    }
    return(0)
}
# Doing it for all scenarios:
checks <- pmap_dbl(as.list(expand.grid(.q = 2:3, .e = -1:1, .d = -1:1)), check_scenarios)
# Sums to zero, so the above description is correct:
sum(checks)
```



## When are final lineage sets reached?


### From initial simulations:

For all scenarios, the final sets of lineages are reached very early:
$t \le$ 10,001 for $d \le 0$ and 
$t \le$ 100,001 for $d > 0$.


```{r sim_dfs}
# Data frame of traits and N through time:
sim_df <- pmap_dfr(as.list(expand.grid(.q = 2:3, .e = -1:1, .d = -1:1)), 
                   function(.q, .e, .d) {
                       qg_ <- get_sim(.e, .d, .q)
                       nv <- mutate(qg_$nv, eta = .e, d = .d, q = .q,
                                    trait = paste(trait))
                       return(nv)
                   })
# When each one reaches final set of lineages:
sim_df %>%
    group_by(q, eta, d, rep, time) %>% 
    summarize(n_spp = n() / q[[1]]) %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(n_spp_equil = which(n_spp == final_spp)[1],
              t_n_spp_equil = time[n_spp_equil]) %>% 
    group_by(q, eta, d) %>% 
    summarize(max_t = max(t_n_spp_equil)) %>% 
    ungroup()
```



### Narrowing it down a bit:

I have a suspicion that it's even earlier than 100,001 and 10,001, so I'm going
to try to a max of 5,000 time steps and see if that gets us to the final
lineage sets.

```{r tran_dyn_short, eval = FALSE}
# Takes ~8 min
sim_df <- pmap_dfr(as.list(expand.grid(.q = 2:3, .e = -1:1, .d = -1:1)),
                    function(.q, .e, .d) {
                        seed <- qg_seeds %>%
                            filter(n_traits == .q, eta_par == .e, d_par == .d) %>%
                            .[["seed"]]
                        args_ <- quant_gen_args(.e, .d, .q)
                        args_$max_t <- 5000L
                        args_$save_every <- 10L
                        args_$show_progress <- FALSE
                        set.seed(seed)
                        qg_ <- do.call(quant_gen, args_)
                        nv <- mutate(qg_$nv, eta = args_$eta, d = args_$d, q = .q,
                                      trait = paste(trait))
                        return(nv)
                    }) %>%
    select(eta, d, everything()) %>%
    mutate_at(vars(eta, d, trait), factor)

max_times <- sim_df %>%
    group_by(q, eta, d, rep, time) %>% 
    summarize(n_spp = n() / as.integer(paste(q[[1]]))) %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(n_spp_equil = which(n_spp == final_spp)[1],
              t_n_spp_equil = time[n_spp_equil]) %>% 
    group_by(q, eta, d) %>% 
    summarize(max_t = max(t_n_spp_equil)) %>% 
    ungroup() %>% 
    mutate_at(vars(eta, d), ~ as.numeric(paste(.)))

max_times
```

```{r write-max_times, echo = FALSE, eval = FALSE}
# This was done for the initial run so that I don't have to run the chunk above:
write_csv(max_times, "results/quant_gen/max_times.csv")
```

```{r read-print-max_times, echo = FALSE}
max_times <- read_csv("results/quant_gen/max_times.csv", col_types = "iddi")
print(max_times)
```


It looks like 5,000 time steps is more than enough for all scenarios.


### Even narrower:

Next, I'm going to use `max_times` to inform simulation times to get
even finer-scale detail.


```{r tran_dyn_shortest, eval = FALSE}
# Takes ~4 min
sim_df <- pmap_dfr(as.list(expand.grid(.q = 2:3, .e = -1:1, .d = -1:1)),
                    function(.q, .e, .d) {
                        seed <- qg_seeds %>%
                            filter(n_traits == .q, eta_par == .e, d_par == .d) %>%
                            .[["seed"]]
                        max_t <- max_times %>%
                            filter(q == .q,
                                   sign(eta) == sign(.e),
                                   sign(d) == sign(.d)) %>%
                            .[["max_t"]]
                        args_ <- quant_gen_args(.e, .d, .q)
                        args_$max_t <- max_t - 1L
                        args_$save_every <- 5L
                        args_$show_progress <- FALSE
                        if (max_t < 100) args_$save_every <- 1L
                        set.seed(seed)
                        qg_ <- do.call(quant_gen, args_)
                        nv <- mutate(qg_$nv, eta = args_$eta, d = args_$d, q = .q,
                                      trait = paste(trait))
                        return(nv)
                    }) %>%
    select(q, eta, d, everything()) %>%
    mutate(trait = factor(trait),
           q = as.integer(q),
           rep = as.integer(paste(rep)))
```

```{r write-sim_df-finest-scale, echo = FALSE, eval = FALSE}
# This was done for the initial run so that I don't have to run the chunk above:
saveRDS(sim_df, "results/quant_gen/short_sims.rds")
```

```{r read-sim_df-finest-scale, echo = FALSE}
sim_df <- readRDS("results/quant_gen/short_sims.rds")
```



## Plotting trait value changes

I'm not going to plot all 100 reps and `r nrow(sim_df)` rows of data,
so I need to find representative repetitions to use.
I started by plotting 6 randomly selected reps, then I visually narrowed that down to 2.
The commented part below is how I generated the first 6.

```{r representative-reps}
# set.seed(798424537)
# plot_reps <- list(q2 = sort(sample.int(100, 6)),
#                   q3 = sort(sample.int(100, 6)))
plot_reps <- list(q2 = c(33, 76), q3 = c(9, 71))
```

Now I'll filter `sim_df` for these reps.

```{r filter-sim_df}
sim_df <- sim_df %>% 
    filter((rep %in% plot_reps$q2 & q == 2) | (rep %in% plot_reps$q3 & q == 3))
```


I'm going to re-define `max_times` to have data for each rep.

```{r new-max_times}
max_times <- sim_df %>%
    group_by(q, eta, d, rep, time) %>% 
    summarize(n_spp = n() / q[[1]]) %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(max_t = time[which(n_spp == final_spp)[1]]) %>% 
    ungroup()
```


Based on trial and error, the function below makes one plot for a given set of
`eta`, `d`, and `q` values. It can have a legend or not.

```{r one_plot-fxn}
one_plot <- function(.eta, .d, .q, do_legend = FALSE) {
    plot_reps_ <- plot_reps[[paste0("q", .q)]]
    df_ <- sim_df %>% 
        filter(q == .q, sign(eta) == sign(.eta), sign(d) == sign(.d), 
               rep %in% plot_reps_)
    if (max(df_$time) < 50) {
        x_breaks <- c(0, 10, 20)
    } else if (max(df_$time) < 2000) {
        x_breaks <- c(0, 500, 1e3)
    } else {
        x_breaks <- c(0, 1000, 2000)
    }
    y_max <- ifelse(.q == 2, 3.616895, 4.999777)
    max_times_ <- max_times %>%
        filter(q == .q, sign(eta) == sign(.eta), sign(d) == sign(.d), 
               rep %in% plot_reps_)
    real_eta <- max_times_$eta[1]
    real_d <- max_times_$d[1]
    p <- df_ %>%
        ggplot(aes(time, value)) +
        geom_vline(data = max_times_, aes(xintercept = max_t), linetype = 2) +
        geom_line(aes(group = interaction(spp, trait), color = trait), size = 0.25) +
        scale_color_viridis_d("Trait:", alpha = 0.35, end = 0.9,
                              guide = guide_legend(override.aes = list(alpha = 1, 
                                                                       size = 1))) +
        facet_wrap(~ rep, nrow = 2) +
        theme(strip.background = element_blank(),
              strip.text = element_blank(),
              axis.text = element_text(size = 8),
              axis.title = element_blank()) +
        scale_y_continuous(breaks = c(-2, 0, 2), limits = c(-1,1) * y_max) +
        scale_x_continuous(breaks = x_breaks)
    if (do_legend) {
        p <- p + theme(legend.position = "top", legend.justification = "center")
    } else {
        p <- p + theme(legend.position = "none")
    }
    return(p)
}
```



The objects below are for the labels at the top, right, bottom, and left.

```{r label-objects}
lab_common <- ggplot() +
    theme_nothing() +
    scale_x_continuous(limits = 0:1) +
    scale_y_continuous(limits = 0:1)
top_labs <- lab_common +
    geom_text(aes(x = c(1/6, 0.53, 0.9), y = 0.5,
                  label = sprintf("italic(d) == %.2g", c(-0.1, 0, 1e-4))),
              hjust = 0.5, vjust = 0.5, parse = TRUE, size = 5)
right_labs <- lab_common +
    geom_text(aes(y = c(1/6, 0.53, 0.9), x = 0.5,
                  label = sprintf("eta == %.2f", c(0.1, 0, -0.1))),
              hjust = 0.5, vjust = 0.5, angle = 270, parse = TRUE, size = 5)
bot_labs <- lab_common +
    geom_text(aes(x = 0.5, y = 0.5, label = "Time"),
              hjust = 0.5, vjust = 0.5, size = 6)
left_labs <- lab_common +
    geom_text(aes(x = 0.5, y = 0.5, label = "Trait value"),
              hjust = 0.5, vjust = 0.5, angle = 90, size = 6)
```


The objects below are the legends and main plots:

```{r main-plots-legends}
main_plots2 <- plot_grid(plotlist = map2(rep(-1:1, each=3), rep(-1:1, 3), one_plot,
                                          .q = 2),
                          align = "hv", nrow = 3, labels = "AUTO",
                         hjust = 0)
legend2 <- get_legend(one_plot(-1, -1, 2, TRUE))
main_plots3 <- plot_grid(plotlist = map2(rep(-1:1, each=3), rep(-1:1, 3), one_plot, 
                                          .q = 3),
                            align = "hv", nrow = 3, labels = "AUTO")
legend3 <- get_legend(one_plot(-1, -1, 3, TRUE))
```


Below are the combined plots, including the legends and labels.

```{r combined-plots}
trans_plots2 <- plot_grid(NULL, legend2, NULL,
                          NULL, top_labs, NULL,
                          left_labs, main_plots2, right_labs,
                          NULL, bot_labs, NULL,
                          ncol = 3, rel_widths = c(0.05, 1, 0.05), 
                          rel_heights = c(0.05, 0.05, 1, 0.05))
trans_plots3 <- plot_grid(NULL, legend3, NULL,
                          NULL, top_labs, NULL,
                          left_labs, main_plots3, right_labs,
                          NULL, bot_labs, NULL,
                          ncol = 3, rel_widths = c(0.05, 1, 0.05), 
                          rel_heights = c(0.05, 0.05, 1, 0.05))
```


```{r save-figures, eval = FALSE}
ggsave("figures/transient_dynamics_q2.pdf", trans_plots2, width = 6.5, height = 9)
ggsave("figures/transient_dynamics_q3.pdf", trans_plots3, width = 6.5, height = 9)
```

