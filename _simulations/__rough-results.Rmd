---
title: "Results"
author: "Lucas A. Nell"
date: ""
output: word_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, eval = TRUE}

# RUN THIS INSTEAD OF USING CMD-SHIFT-K IN RSTUDIO:
# rmarkdown::render("_simulations/__rough-results.Rmd")

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, 
                      eval = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))

# load packages
suppressPackageStartupMessages({
    library(sauron)
    library(tidyverse)
    library(grid)
    library(parallel)
    library(cowplot)
    library(egg)
})

# This sets plotting device on LAN computer:
if (!isTRUE(getOption('knitr.in.progress')) && file.exists(".Rprofile")) {
  source(".Rprofile")
}


# Clean captions
cc <- function(.x) {
    .x <- gsub("\n", "", .x)
    .x <- gsub("\\s+", " ", .x)
    return(.x)
}

# whether to re-do simulations (use rds files otherwise)
.REDO_SIMS <- FALSE
# whether to re-save plots
.RESAVE_PLOTS <- FALSE
# number of threads to use for simulations
.N_THREADS <- 3



# Where to save rds files
rds <- function(.x) {
    sprintf("~/GitHub/Wisconsin/sauron/_simulations/__rough-results/%s.rds",
           gsub("\\.rds$", "", gsub("^\\/", "", .x)))
}



save_plot <- function(plot_obj, .width, .height, .prefix = NULL, .suffix = NULL) {
    fn <- gsub("_p$", "", paste(substitute(plot_obj)))
    if (!is.null(.prefix)) fn <- paste0(.prefix, fn)
    if (!is.null(.suffix)) fn <- paste0(fn, .suffix)
    fn <- sprintf("_simulations/__rough-results/%s.pdf", fn)
    message(fn)
    plot_fun <- ifelse(inherits(plot_obj, "egg"), print, plot)
    cairo_pdf(fn, width = .width, height = .height)
    plot_fun(plot_obj)
    dev.off()
    invisible(NULL)
}

unq_spp_filter <- function(..., .prec = 0.001) {
    V <- list(...)
    V <- do.call(cbind, V)
    V <- split(V, row(V))
    return(as.logical(sauron:::unq_spp_cpp(V, precision = .prec)))
}

group_spp <- function(..., .prec = 0.001) {
    V <- list(...)
    V <- do.call(cbind, V)
    V <- split(V, row(V))
    return(sauron:::group_spp_cpp(V, precision = .prec))
}


.q <- 3

```


## 1. Trait outcomes

```{r trait-outcomes-sims}

set.seed(1652339501)
etas <- runif(.q * ((.q - 1) / 2), 0.1, 0.4)



one_eta_combo <- function(sign1, sign2, sign3) {
  
    # sign1 = 1; sign2 = 1; sign3 = 1
    # rm(sign1, sign2, sign3)

    C <- matrix(0, .q, .q)
    C[lower.tri(C)] <- abs(etas) * c(sign1, sign2, sign3)
    # sample(c(-1, 1), .q, TRUE)
    C <- C + t(C)
    diag(C) <- 1

    trait_to <- quant_gen(q = .q, eta = C, d = 0.1, max_t = 20e3L, n_reps = 24,
                          save_every = 0L, n = 100, N0 = rep(1, 100),
                          start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
                          show_progress = FALSE)
    
    output <- list(jacs = jacobians(trait_to),
                   ts = trait_to$nv %>%
                       mutate(trait = paste0("V", trait)) %>%
                       spread(trait, value) %>%
                       filter(unq_spp_filter(V1, V2, V3)) %>%
                       select(starts_with("V")) %>%
                       mutate(eta1 = C[2,1], eta2 = C[3,1], eta3 = C[3,2]))
    return(output)
}


if (.REDO_SIMS) {
    # Takes ~6 min with 2 threads
    set.seed(145746935)
    eta_sims <- crossing(sign1 = -1:1, sign2 = -1:1, sign3 = -1:1) %>%
        pmap(one_eta_combo)
    saveRDS(eta_sims, rds("eta_sim"))
} else {
    eta_sims <- readRDS(rds("eta_sim"))
}
eta_sim_df <- map_dfr(eta_sims, ~.x$ts)
# eta_sim_jacs <- do.call(c, map(eta_sims, ~.x$jacs))
# 
# 
# # These eigenvalues show that any points with a trait equal to zero aren't 
# # stable. This is because we're forcing them to be >= 0, not doing it
# # mathematically in the equations themselves.
# eta_sim_eigs <- crossing(sign1 = -1:1, sign2 = -1:1, sign3 = -1:1, 
#                          rep = 1L:24L) %>%
#     mutate(eigen = map_dbl(eta_sim_jacs, ~ max(eigen(.x)$values)))
# 
# eta_sim_eigs %>% 
#     group_by(sign1, sign2, sign3) %>% 
#     summarize(e_min = min(eigen),
#               e_max = max(eigen)) %>% 
#     ungroup() %>% 
#     as.data.frame()

```


With three traits, we first generated the 3 $\eta$ magnitudes from a
uniform distribution from 0.1 to 0.4.
The values we ended up with were 
$\eta_1 = 0.207$, $\eta_2 = 0.190$, and $\eta_3 = 0.257$. 
We then simulated communities of 100 species, each with random starting
trait values ($\sim \text{N}(0, 2)$, truncated to be $\ge 0$).
We did this 24 times for each of the 27 permutations of 
$\eta_1$, $\eta_2$, and $\eta_3$ being negative, zero, or positive.
Because we were only interested in the possible trait values for surviving
species, we set $d = 0.1$ (non-conflicting evolution) so that many species 
survived and surveyed the trait space more effectively.
We recorded the trait values of the surviving species.


This resulted in a number of outcomes (Figure 1).
When at least one combination was sub-additive, only one set of trait 
values were present in surviving species.
What those trait values were depended on the exact combination.
With all sub-additive combinations, all three traits were maximized.
The six other permutations of $\ge 2$ sub-additive combinations varied but 
all had high values of $\eta_2$ and usually had high values of $\eta_3$.
With only one sub-additive combination, the combination that was sub-additive
determined which of the three trait states the surviving species possessed.


We observed alternative trait states only when no trait combinations 
were sub-additive.
When all combinations were super-additive, there were three alternative 
trait states: one for each trait being maximized while the others 
equaled zero.
With two super-additive and one neutral combinations, species traits were 
along a neutrally stable quarter-ring along one axis.
With one super-additive and two neutral combinations, species traits were 
along a neutrally stable half-ring along two axes.
Traits existed along a neutrally stable three-dimensional shell when all 
traits were neutral.



__NOTE:__ When $d$ is large enough ($d = 0.9$ does it for these parameter values),
you can get additional trait outcomes.
In some cases, it adds 1 or 2 additional trait state(s), but in the case
of 1 sub-additive, 1 neutral, and 1 super-additive trait (i.e., "1 of each"),
it allows for many possibilities:
anywhere on a sub-section of the neutral ring (like
the "2 super, 1 neutral" scenario, but even more reduced).
The species that exist at these additional trait states 
have at least slightly lower densities than the others at the trait state
that exists when $d = 0.1$.
Is this interesting or likely an artifact?


```{r trait-outcomes-caption}
to_cap <- "Figure 1.
           Unique trait values for surviving species, for all 27 combinations
           of pairwise combinations of traits being 
           sub-additive ($\\eta < 0$ or \"$-$\"), neutral ($\\eta = 0$), 
           or super-additive ($\\eta > 0$ or \"$+$\").
           The size of points indicates the value for trait 3.
           Sub-panels separate the number of pairwise combinations (out of 3)
           that are sub-additive, neutral, or super-additive.
           All but the \"all super\" and \"all neutral\" sub-panels 
           contain multiple pairwise combinations, so each specific combination 
           is separated by color and indicated by the colored label.
           The symbol $0^{+}$ inside labels indicates when that $\\eta$ can be
           $\\ge 0$.
           Therefore, all 3 points in the \"1 sub\" sub-panel represent 
           4 combinations each.
           When one sub-panel contains multiple points of the same color, 
           this indicates that multiple alternative states are possible
           for that combination."
```

```{r trait-outcomes-results, fig.cap = cc(to_cap), fig.width=6, fig.height=5}


### The code below explores what happens when d >= 0.9
#
# eta_sim_df %>% 
#     filter((eta1 < 0 & eta2 == 0 & eta3 > 0) |
#                (eta1 < 0 & eta2 > 0 & eta3 == 0) |
#                (eta1 == 0 & eta2 < 0 & eta3 > 0) |
#                (eta1 == 0 & eta2 > 0 & eta3 < 0) |
#                (eta1 > 0 & eta2 == 0 & eta3 < 0) |
#                (eta1 > 0 & eta2 < 0 & eta3 == 0)) %>% 
#     group_by(eta1, eta2, eta3) %>% 
#     summarize(N = n()) %>% 
#     ungroup()
# 
# 
# sign1 = -1; sign2 = -1; sign3 = 1
# C <- matrix(0, .q, .q)
# C[lower.tri(C)] <- abs(etas) * c(sign1, sign2, sign3)
# # sample(c(-1, 1), .q, TRUE)
# C <- C + t(C)
# diag(C) <- 1
# 
# trait_to <- quant_gen(q = .q, eta = C, d = 0.9, max_t = 20e3L, n_reps = 24,
#                       save_every = 100L, n = 100, N0 = rep(1, 100),
#                       start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
#                       show_progress = TRUE)
# 
# trait_to$nv %>%
#     filter(time == max(time)) %>% 
#     mutate(trait = paste0("V", trait)) %>%
#     spread(trait, value) %>%
#     filter(unq_spp_filter(V1, V2, V3)) %>%
#     select(starts_with("V")) %>%
#     mutate(eta1 = C[2,1], eta2 = C[3,1], eta3 = C[3,2])
# 
# trait_to$nv %>%
#     filter(time == max(time)) %>% 
#     mutate(trait = paste0("V", trait)) %>%
#     spread(trait, value) %>%
#     # filter(unq_spp_filter(V1, V2, V3)) %>%
#     # select(starts_with("V")) %>%
#     filter(!((V1 - 1.63)^2 < 0.001 & (V2 - 1.63)^2 < 0.001 & V3 == 0)) %>% 
#     .[["N"]] %>% 
#     range()
# 
# 
# 
# 
# # # A tibble: 1 x 6
# #      V1    V2    V3   eta1  eta2  eta3
# #   <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>
# # 1  1.63  1.63     0 -0.207     0 0.257
# 
# 
# trait_to$nv %>% 
#     filter(trait == 1, rep == 1) %>% 
#     filter(time == max(time))
#     # filter(time < 1000) %>% 
#     ggplot(aes(time, N)) +
#     geom_line(aes(color = spp)) +
#     scale_color_viridis_d(guide = FALSE)
# 
# 





# This function combines id labels for all combinations that have the exact 
# same outcomes. Only used for "1 sub".
# It also processes all id columns to be parsed.
process_ids <- function(z) {
    
    parseable <- function(.id) {
        .id = paste(.id)
        IDD1 = str_sub(.id, 1, 1) %>% 
            {case_when(. == "+" ~ paste0("{}", .),
                       . == "-" ~ paste0(., "''"),
                       . == "0" ~ "0",
                       . == "X" ~ "0^{'+'}",
                       TRUE ~ NA_character_)}
        IDD2 = str_sub(.id, 2, 2) %>% 
            {case_when(. == "-" ~ paste0(., "''"), 
                       . == "X" ~ "0^{'+'}",
                       TRUE ~ .)}
        IDD3 = str_sub(.id, 3, 3) %>% 
            {case_when(. == "+" ~ paste0(., "{}"),
                      . == "-" ~ paste0(., "''"),
                      . == "0" ~ "0",
                      . == "X" ~ "0^{'+'}",
                      TRUE ~ NA_character_)}
        if(any(is.na(IDD1)) || any(is.na(IDD3))) {
            print(.id[is.na(IDD1) | is.na(IDD3)])
            stop("Non-programmed option in `parseable`")
        }
        paste0(IDD1, IDD2, IDD3) %>% 
            str_replace_all("''0", "0") %>% 
            str_replace_all("\\{\\}0", "0") %>% 
            str_replace_all("\\}0", "\\} * 0") %>% 
            str_replace_all("00", "0 * 0") %>% 
            str_replace_all("00", "0 * 0")
    }
    

    if (z$p_groups[1] != "'1 sub'") return(mutate(z, id = parseable(id)))
    
    one_chr <- function(.x) {
        .xx <- .x %>% 
            str_split("") %>% 
            {lapply(1:length(.[[1]]), function(i) map_chr(., ~ .x[[i]]))} %>% 
            map_chr(function(x) {
                xx <- unique(x)
                if (length(xx) == 1) return(xx)
                if (all(xx %in% c("0", "+"))) return("X")
                return(NA_character_)
            })
        if (any(is.na(.xx))) stop("Non-programmed input to `one_chr`")
        return(paste(.xx, collapse = ""))
    }

    z %>%
        mutate(color_group = group_spp(V1, V2, V3) + 1L) %>%
        mutate_at(vars(id), paste) %>% 
        arrange(p_groups, color_group) %>%
        group_by(p_groups, color_group) %>%
        summarize(V1 = mean(V1),
                  V2 = mean(V2),
                  V3 = mean(V3),
                  id = one_chr(id)) %>%
        ungroup() %>%
        mutate(id = parseable(id))

}

p_group_levels <- c("{} >= '2 sub'", "'1 sub'",
                    "'all super'",
                    "'2 super, 1 neutral'", "'2 neutral, 1 super'", 
                    "'all neutral'")


trait_outcomes_p_df <- eta_sim_df %>%
    mutate_at(vars(starts_with("eta")),
              ~ factor(sign(.x), levels = -1:1, labels = c("-", "0", "+"))) %>%
    mutate(id = interaction(eta1, eta2, eta3, sep = "")) %>%
    group_by(id) %>%
    filter(unq_spp_filter(V1, V2, V3, .prec = 0.1)) %>%
    ungroup() %>%
    mutate(n_p = str_count(id, "\\+"),
           n_n = str_count(id, "\\-"),
           n_z = str_count(id, "0"),
           p_groups = case_when(n_n >= 2 ~ p_group_levels[1],
                                n_n == 1  ~ p_group_levels[2],
                                n_p == 3 ~ p_group_levels[3],
                                n_p == 2 & n_z == 1 ~ p_group_levels[4],
                                n_z == 2 & n_p == 1 ~ p_group_levels[5],
                                n_z == 3 ~ p_group_levels[6],
                                TRUE ~ NA_character_)) %>%
    select(-starts_with("n", ignore.case = FALSE)) %>%
    # filter(is.na(p_groups))  ## <-- check that this yields no rows
    mutate(p_groups = factor(p_groups, levels = p_group_levels)) %>%
    arrange(p_groups) %>% 
    split(.$p_groups) %>%
    map(~ mutate(.x, color_group = id %>% droplevels() %>% as.integer())) %>%
    map_dfr(process_ids) %>%
    mutate_at(vars(color_group, id), factor) %>%
    arrange(desc(V3))



.pal <- function(.a = 1) viridisLite::plasma(7, end = 0.85, 
                                             alpha = .a)[c(6,4,1,3,5,7,2)]


trait_outcomes_p <- trait_outcomes_p_df %>%
    ggplot(aes(V1, V2, size = V3, color = color_group)) +
    geom_point(aes(fill = color_group), shape = 21) +
    geom_text(data = trait_outcomes_p_df %>%
                  filter(!grepl("^\\'all", p_groups)) %>%
                  group_by(p_groups, color_group, id) %>%
                  summarize_at(vars(V1, V2), median) %>%
                  ungroup() %>% 
                  mutate(V1 = case_when(id == "{}+0+{}" ~ V1 - 0.3,
                                        id == "0 * 0+{}" ~ V1 - 0.3,
                                        id == "{}+0 * 0" ~ V1 - 0.1,
                                        id == "0-''-''" ~ V1 - 0.4,
                                        id == "-''-''+{}" ~ V1 - 0.1,
                                        id == "{}+-''-''" ~ V1 - 0.3,
                                        id == "-''+-''" ~ V1 - 0.3,
                                        id == "-0-''" ~ V1 - 0.4,
                                        TRUE ~ V1),
                         V2 = case_when(id == "{}+0+{}" ~ V2 + 0.05,
                                        id == "0 * 0+{}" ~ V2 + 0.05,
                                        id == "{}+0 * 0" ~ V2 + 0.05,
                                        id == "0+0" ~ V2 - 0.05,
                                        id == "0-''-''" ~ V2 - 0.6,
                                        id == "-''-0" ~ V2 - 0.4,
                                        id == "-''-''+{}" ~ V2 - 0.3,
                                        id == "-''-''-''" ~ V2 - 0.1,
                                        id == "{}+-''-''" ~ V2 - 0.6,
                                        id == "-0-''" ~ V2 + 0.05,
                                        TRUE ~ V2)) %>%
                  identity(),
              aes(label = id), size = 9 / 2.835, hjust = 0, vjust = 0, parse = TRUE,
              fontface = "bold", lineheight = 0.75, nudge_x = 0.2, nudge_y = 0.2) +
    scale_size_continuous("Trait 3", range = c(2, 6), breaks = 0.5 * 1:3) +
    scale_x_continuous("Trait 1", breaks = 0:2) +
    scale_y_continuous("Trait 2", breaks = 0:2) +
    coord_equal(xlim = c(0, 2.5), ylim = c(0, 2.5)) +
    facet_wrap(~ p_groups, nrow = 3, labeller = label_parsed) +
    theme(strip.text = element_text(size = 10),
          panel.border = element_rect(size = 0.5, fill = NA)) +
    scale_color_manual(values = .pal(), guide = FALSE) +
    scale_fill_manual(values = .pal(0.25), guide = FALSE) +
    NULL


if (.RESAVE_PLOTS) save_plot(trait_outcomes_p, 6, 5, "1-")

trait_outcomes_p


```





## 2. Coexistence





```{r coexistence-caption}
coex_cap <- "Figure 2.
             Number of surviving species for
             (A) all permutations of three traits being conflicting (\"-\") 
             or non-conflicting (\"+\"),
             (B) varying values of $d_3$ when $d_1$ and $d_2$ are kept positive
             (i.e., traits 1 and 2 are kept non-conflicting), and
             (C) surviving species through time with $d_3 = -10^{-2}$ and 
             $d_3 = -10^{-4}$.
             (A) Numbers above segments indicate the number of traits that are 
             non-conflicting."
```

```{r coexistence-results, fig.cap = cc(coex_cap), fig.width=6.5, fig.height=5.0}

# =======================================================================================`
# =======================================================================================`

#               II. Coexistence ----

# =======================================================================================`
# =======================================================================================`


set.seed(532052696)
ds <- exp(runif(.q, -6, -2))





# ------------------------------*
# __ all combinations ----
# ------------------------------*

# All combinations of - or + d values

one_d_combo <- function(sign1, sign2, sign3) {

    .d <- ds * c(sign1, sign2, sign3)
    
    C <- matrix(0.2, .q, .q)
    diag(C) <- 1

    Z <- quant_gen(q = .q, eta = C, d = .d, max_t = 20e3L, n_reps = 24,
              save_every = 0L, n = 100, N0 = rep(1, 100),
              start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
              show_progress = FALSE)

    Z$nv %>%
        mutate(trait = paste0("V", trait)) %>%
        spread(trait, value) %>%
        # filter(unq_spp_filter(V1, V2, V3)) %>%
        mutate(d1 = .d[1], d2 = .d[2], d3 = .d[3])

}




if (.REDO_SIMS) {
    # Takes ~45 sec w/ 2 threads
    set.seed(751678518)
    d_sim_df <- crossing(sign1 = c(-1,1), sign2 = c(-1,1), sign3 = c(-1,1)) %>%
        pmap_dfr(one_d_combo)
    saveRDS(d_sim_df, rds("all_d_sim"))
} else {
    d_sim_df <- readRDS(rds("all_d_sim"))
}






lab_df <- tibble(idd = c(1, 2, 5, 8) - 0.25, idd_e = c(1, 4, 7, 8) + 0.25,
                 N = c(rep(10, 3), 50),
                 lab = sprintf("%i", 0:3))

coexist_all_d_p <- d_sim_df %>%
    group_by(d1, d2, d3, rep) %>%
    summarize(N = n()) %>%
    ungroup() %>%
    mutate_at(vars(starts_with("d")),
              ~ factor(sign(.x), levels = c(-1,1), labels = c("-", "+"))) %>%
    mutate(id = interaction(d1, d2, d3, sep = "{}"),
           id = factor(id, levels = levels(id),
                       labels = sprintf("%s{}", levels(id))),
           n_p = str_count(id, "\\+"),
           idd = interaction(n_p, id, sep = "", lex.order = TRUE, drop = TRUE),
           idd = factor(idd, levels = levels(idd),
                        labels = gsub("0|1|2|3", "", levels(idd)))) %>%
    ggplot(aes(idd, N)) +
    geom_jitter(width = 0.25, alpha = 0.5, height = 0, 
                color = "dodgerblue4", fill = "dodgerblue", shape = 21) +
    geom_segment(data = lab_df, aes(xend = idd_e, yend = N)) +
    geom_text(data = lab_df, aes(x = (idd + idd_e) / 2, y = N + 2, label = lab),
              hjust = 0.5, vjust = 0) +
    # facet_wrap(~ n_p, scales = "free_x") +
    scale_y_continuous("Number of surviving species", limits = c(0, 55),
                       breaks = c(0, 25, 50)) +
    scale_x_discrete(expression("Sign of" ~ d[1] * "," ~ d[2] * "," ~ d[3]),
                     labels = rlang::parse_exprs) +
    scale_color_viridis_d(guide = FALSE, end = 0.8, option = "B") +
    theme(strip.text = element_text(size = 8),
          axis.text.x = element_text(size = 11)) +
    NULL




# ------------------------------*
# __ slowly vary 1 ----
# ------------------------------*

# Keep 2 d values positive, make the last one go slowly negative

one_d_combo_vary_one <- function(.d3, .max_t) {

    .d <- c(0.1, 0.1, .d3)
    
    C <- matrix(0.2, .q, .q)
    diag(C) <- 1


    Z <- quant_gen(q = .q, eta = C, d = .d, max_t = .max_t, n_reps = 24,
                   save_every = 0L, n = 100, N0 = rep(1, 100),
                   start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
                   show_progress = FALSE)

    Z$nv %>%
        spread(trait, value) %>%
        group_by(rep) %>%
        summarize(n_spp = n()) %>%
        ungroup() %>%
        mutate(d3 = .d3) %>%
        identity()

}


if (.REDO_SIMS) {
    # Takes ~30 min
    set.seed(807582316)
    one_d_sim_df <- tibble(.d3 = c(-10^(c(-2, -3, -4)), 0, 10^(c(-4, -3, -2))),
                        .max_t = 200e3L) %>%
        mutate(.max_t = ifelse(.d3 == -1e-4, 2e6L, .max_t)) %>%
        pmap_dfr(one_d_combo_vary_one)
    saveRDS(one_d_sim_df, rds("one_d_sim"))
} else {
    one_d_sim_df <- readRDS(rds("one_d_sim"))
}




lab_fun <- function(.x) {
    labs <- paste(.x)
    labs[.x != 0] <- sprintf("%s10^{%i}",
                             sign(.x[.x != 0]) %>% paste() %>% str_remove("1"),
                             abs(.x[.x != 0]) %>% log10())
    return(labs)
}

coexist_one_d_p <- one_d_sim_df %>%
    mutate(d3 = factor(d3, levels = d3 %>% sort() %>% unique(),
                       labels = d3 %>% sort() %>% unique() %>% lab_fun())) %>%
    ggplot(aes(d3, n_spp)) +
    geom_jitter(width = 0.2, alpha = 0.5, height = 0, 
                color = "dodgerblue4", fill = "dodgerblue", shape = 21) +
    scale_color_viridis_d(guide = FALSE, end = 0.95, option = "D") +
    scale_x_discrete(expression("Value of" ~ d[3]), labels = rlang::parse_exprs) +
    scale_y_continuous("Number of surviving species", breaks = c(0, 25, 50),
                       limits = c(0, 55)) +
    NULL





# ------------------------------*
# __ Time series of d3 = -0.01 and d3 = -1e-4 ----
# ------------------------------*

# Same as above, but returns a time series
one_d_combo_vary_one_TS <- function(.d3, .max_t) {
    
    # .d3 = -1e-4; .max_t = 2e6
    # rm(.d3, .max_t, C, Z, .d)
  
    .max_t <- as.integer(.max_t)
    
    C <- matrix(0.2, .q, .q)
    diag(C) <- 1

    .d <- c(0.1, 0.1, .d3)

    Z <- quant_gen(q = .q, eta = C, d = .d, max_t = .max_t, n_reps = 24,
                   save_every = .max_t %/% 100L, n = 100, N0 = rep(1, 100),
                   start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
                   show_progress = TRUE)

    Z$nv %>%
        filter(trait == 1) %>%
        group_by(rep, time) %>% 
        summarize(N = n()) %>% 
        ungroup() %>% 
        mutate(d3 = .d3) %>% 
        identity()

}



if (.REDO_SIMS) {
    # Takes ~7 min
    set.seed(1821003492)
    one_d_TS_sim_df <- tibble(.d = c(-1e-2, -1e-4), .max_t = c(10e3L, 2e6L)) %>% 
        pmap_dfr(one_d_combo_vary_one_TS)
    saveRDS(one_d_TS_sim_df, rds("one_d_TS_sim"))
} else {
    one_d_TS_sim_df <- readRDS(rds("one_d_TS_sim"))
}




one_d_TS_p <- one_d_TS_sim_df %>%
    mutate(d3 = factor(d3, levels = c(-0.01, -1e-4),
                      labels = sprintf("d[3] == %s", c("-10^{-2}", "-10^{-4}")))) %>% 
    filter(time < 750e3) %>%
    mutate(time = time / 1000L) %>% 
    ggplot(aes(time, N)) +
    geom_line(aes(group = rep), alpha = 0.5, size = 0.5, color = "dodgerblue") +
    facet_wrap(~ d3, nrow = 1, label = label_parsed, scales = "free_x") +
    scale_y_continuous("Number of species", breaks = c(0, 50, 100)) +
    scale_x_continuous("Time (1,000 generations)", 
                       breaks = scales::breaks_extended(n = 4)) +
    NULL








# ------------------------------*
# __ combine them ----
# ------------------------------*



coexist_p <- ggarrange(coexist_all_d_p + theme(axis.title.y = element_blank()), 
                       coexist_one_d_p + theme(axis.title.y = element_blank()), 
                       one_d_TS_p + theme(axis.title.y = element_blank()), 
                       heights = c(1, 1, 0.75),
                       left = "Number of surviving species",
                       ncol = 1, labels = LETTERS[1:3],
                       label.args = list(gp = gpar(fontsize = 14, 
                                                   fontface =  "plain"),
                                         vjust = 2, hjust = -3))


if (.RESAVE_PLOTS) save_plot(coexist_p, 6.5, 6, "2-")



```




To assess how conflicting and non-conflicting evolution leads to coexistence,
we conducted similar simulations to the previous section, for each of the 
8 permutations of the three traits' evolution being conflicting or 
non-conflicting (i.e., $d < 0$ or $d > 0$, respectively).
The magnitudes of the $d$ values used for these simulations were generated as 
$\log(d) \sim \text{U}(-6, -2)$.
The values we ended up with were $d_1 = `r sprintf("%#.3g", ds[1])`$,
$d_2 = `r sprintf("%#.3f", ds[2])`$, and
$d_3 = `r sprintf("%#.3g", ds[3])`$.
We recorded the number of species coexisting at the end of each repetition.
We also did another set of simulations where the first two traits were kept
non-conflicting ($d_1 = d_2 = 0.1$), while the value of $d_3$ varied 
from $-10^{-2}$ to $10^{-2}$.
We used $\eta_1 = \eta_2 = \eta_3 = 0.2$ for all simulations here.

The first set of simulations shows that
coexistence occurs only when evolution for all traits is non-conflicting 
(Figure 2A).
From the second set of simulations, we see that a value of 0 for $d_3$ 
appears to represent a bifurcation with respect to whether 
coexistence can occur (Figure 2B).
Even slightly negative values of $d_3$ cause exclusion to occur, although
a less-negative $d_3$ causes the exclusions to happen much more slowly
(Figure 2C).





## 3. Invasibility


To estimate the invasibility of these equilibrium communities, we started
simulations with the equilibrium abundances and trait values for communities
with $\eta$ values and $d$ magnitudes from the previous section, and 
with all traits except for the first being non-conflicting.
The first trait was either conflicting or non-conflicting.
We then added a single invader to the community and simulated the outcomes.
We did this for invaders with starting trait 1 and 2 values that varied
from 0 to 4.
Trait 3 always started at zero for these simulations.
We did this to ease visualization and because two of the three
possible equilibrium trait states had trait 3 equal zero.
Invaders' starting abundances 0.01.
For those simulations that yielded successful invasions, 
we also calculated how much the abundances and traits changed across 
the time series for both invaders and native species:

\begin{align}
\Delta N = \sum_{t=2}^{t_{max}}{ | N_{t} - N_{t-1} | } \\
\Delta V = \sum_{t=2}^{t_{max}}{\sqrt{\sum_{i = 1}^{q}{(v_{i,t} - v_{i,t-1})^2}}}
\end{align}

\noindent We did this in relation to the distance in trait space from 
the nearest equilibrium trait state to the starting trait value for the invader:
$\sqrt{\sum_{i = 1}^{q}{(v_{i} - \hat{v}_{i})^2}}$ at $t = 0$.


When the first trait was conflicting, invaders were never successful, 
whereas they were successful across much of the trait space surrounding the
equilibrium states when it was non-conflicting (Figure 3A).
The total change in abundance was almost always greater when the invader 
started  with traits near state i (Figure 3B).
This is because state i has high trait 2 and low trait 1, whereas
state ii is the opposite.
Because $d_1$ is much lower than $d_2$, species that maximize trait 1
but minimize trait 2 (state ii) greatly reduce competition experienced by 
others but receive little benefit themselves.
Therefore, successful invaders that evolve to state ii will coexist at lower
equilibrium abundances.
Trait change had a linear relationship with starting distance for both 
native species and invaders (Figure 3C).




```{r invasibility-caption}
inv_cap <- "Figure 3.
            Invasibility analysis.
            (A) Invasibility of equilibrium communities for invaders of 
            varying starting trait values and when the first trait has 
            conflicting or non-conflicting evolution.
            Circles represent trait value combinations that were present 
            in the equilibrium population,
            and the two possible states for the non-conflicting case 
            are labelled with the small Roman numerals nearby.
            (B,C) For the invasion-successful, non-conflicting cases, how the
            distance from the nearest equilibrium trait state
            to the invader's starting trait values relates to the
            total change in (B) abundance and (C) traits.
            See text for the equations used to calculate these.
            Invader points are in blue.
            (B) Points representing $\\Delta N$ for the native community 
            (i.e., all non-invader species) are black.
            The sub-panels separate which state the invader started 
            nearest to.
            (C) Each native species is represented by a line with a color 
            indicating that species starting abundance;
            this abundance is also the species' equilibrium abundance.
            "

```


```{r invasibility-results, fig.cap = cc(inv_cap), fig.width=6, fig.height=6}


invade_test <- function(r, .V1, .V2, .dsigns, .comm_N, .comm_V,
                        .V3 = 0, .max_t = 20e3L) {
    
    # .V1 = 1; .V2 = 1; .dsigns = c(1,1,1); .V3 = 0; .max_t = 20e3L
    # rm(.V1, .V2, .dsigns, .V3, .max_t, S, comm_N, comm_V, .n, Z)
    
    .n <- length(.comm_N) + 1
    
    Z <- quant_gen(q = .q, eta = 0.2, d = ds*.dsigns, max_t = .max_t, n_reps = 1,
                   save_every = 100L, n = .n, 
                   N0 = c(.comm_N, 0.01),
                   V0 = c(.comm_V, list(cbind(.V1, .V2, .V3))),
                   start_t = 0, perturb_sd = 0,
                   n_threads = .N_THREADS, show_progress = FALSE) %>%
        .[["nv"]] %>%
        mutate(trait = paste0("V", trait)) %>%
        spread(trait, value) %>%
        mutate(spp = factor(spp, levels = 1:.n, 
                            labels = c(paste0("native_", 1:(.n-1)), "invader")),
               rep = paste(.V1, .V2, .V3, sep = "__"),
               dsigns = paste(.dsigns, collapse = "__"))
    return(Z)
}




if (.REDO_SIMS) {
    # Takes ~18 min w/ 3 threads
    invade_df <- crossing(.V1 = seq(0, 4, 0.1),
                          .V2 = seq(0, 4, 0.1),
                          .dsigns = list(c(-1,1,1), c(1,1,1))) %>%
        mutate(.comm_N = map(.dsigns, function(.ds) {
            d_sim_df %>% 
                filter(sign(d1) == .ds[1],
                       sign(d2) == .ds[2],
                       sign(d3) == .ds[3],
                       rep == 1) %>% 
                .[["N"]]
        }),
        .comm_V = map(.dsigns, function(.ds) {
            d_sim_df %>% 
                filter(sign(d1) == .ds[1],
                       sign(d2) == .ds[2],
                       sign(d3) == .ds[3],
                       rep == 1) %>%
                select(starts_with("V", FALSE)) %>% 
                as.matrix() %>% 
                split(1:nrow(.))
        })) %>% 
        mutate(r = 1:n()) %>%
        pmap_dfr(invade_test)
    saveRDS(invade_df, rds("invade"))
} else {
    invade_df <- readRDS(rds("invade"))
}





invasion_hm_p_df <- invade_df %>%
    filter(time == max(time)) %>% 
    mutate(dsigns = factor(dsigns, levels = c("-1__1__1", "1__1__1"),
                           labels = c("conflicting", "non-conflicting"))) %>%
    group_by(dsigns, rep) %>%
    summarize(invaded = factor(sum(spp == "invader"),
                               levels = 0:1, labels = c("no", "yes")),
              V1 = str_split(rep, "__")[[1]][[1]] %>% as.numeric(),
              V2 = str_split(rep, "__")[[1]][[2]] %>% as.numeric()) %>%
    ungroup() %>%
    select(-rep)



invasion_hm_p <- invasion_hm_p_df %>%
    ggplot(aes(V1, V2)) +
    geom_tile(aes(fill = invaded)) +
    geom_point(data = tibble(V1 = c(0, 2, 2), V2 = c(2, 0, 0),
                             dsigns = c(rep("non-conflicting", 2), "conflicting")),
               size = 4, color = "black", shape = 1) +
    geom_text(data = tibble(V1 = c(0 + 0.4, 2), V2 = c(2, 0 + 0.4),
                             dsigns = rep("non-conflicting", 2),
                            lab = c("i", "ii")),
               aes(label = lab), size = 12 / 2.835, 
              color = "black", fontface = "bold") +
    facet_wrap(~ dsigns, labeller = label_parsed, nrow = 1) +
    xlab("Invader trait 1") +
    ylab("Invader trait 2") +
    scale_fill_viridis_d("successful", begin = 0.3, end = 0.9, option = "C") +
    coord_equal()


# Takes ~20 sec
invasion_move_p_df <- invade_df %>%
    filter(dsigns == "1__1__1") %>% 
    group_by(rep) %>%
    mutate(invaded = sum(time == max(time) & spp == "invader")) %>% 
    ungroup() %>% 
    filter(invaded == 1) %>% 
    select(-dsigns, -invaded) %>% 
    group_by(rep, spp) %>%
    summarize(N0 = N[1],
              mvmt_N = sum(abs(diff(N))),
              mvmt_V1 = sum(abs(diff(V1))),
              mvmt_V2 = sum(abs(diff(V2))),
              mvmt_V = sum(sqrt((V1 - lag(V1))^2 + (V2 - lag(V2))^2 + 
                                    (V3 - lag(V3))^2), na.rm = TRUE), 
              V1 = str_split(rep, "__")[[1]][[1]] %>% as.numeric(),
              V2 = str_split(rep, "__")[[1]][[2]] %>% as.numeric()) %>%
    ungroup() %>%
    select(-rep) %>%
    mutate(distance = ifelse(V1 > V2, sqrt((V1 - 2)^2 + (V2 - 0)^2), 
                             sqrt((V1 - 0)^2 + (V2 - 2)^2)),
           which_pt = ifelse(V1 > V2, "state i", "state ii"))

invasion_move_p_df2 <- invade_df %>%
    filter(dsigns == "1__1__1") %>% 
    group_by(rep) %>%
    mutate(invaded = sum(time == max(time) & spp == "invader")) %>% 
    ungroup() %>% 
    filter(invaded == 1, spp != "invader") %>% 
    select(-dsigns, -invaded) %>% 
    group_by(rep, time) %>%
    summarize(N = sum(N)) %>% 
    group_by(rep) %>%
    summarize(N0 = N[1],
              mvmt_N = sum(abs(diff(N))), 
              V1 = str_split(rep, "__")[[1]][[1]] %>% as.numeric(),
              V2 = str_split(rep, "__")[[1]][[2]] %>% as.numeric()) %>%
    ungroup() %>%
    select(-rep) %>%
    mutate(distance = ifelse(V1 > V2, sqrt((V1 - 2)^2 + (V2 - 0)^2), 
                             sqrt((V1 - 0)^2 + (V2 - 2)^2)),
           which_pt = ifelse(V1 > V2, "state i", "state ii"))



invasion_moveN_p <- invasion_move_p_df %>%
    filter(spp == "invader") %>% 
    ggplot(aes(distance, mvmt_N)) +
    geom_point(data = invasion_move_p_df2, shape = 1) +
    geom_point(shape = 1, color = "dodgerblue") +
    facet_wrap(~ which_pt, nrow = 1) +
    scale_y_continuous(expression(italic(Delta * "N")),
                       breaks = c(0, 0.2, 0.4)) +
        scale_x_continuous("Starting distance from equilibrium trait state",
                       breaks = c(0, 0.4, 0.8, 1.2)) +
    scale_color_viridis_c(expression(N[0]), begin = 0.1, end = 0.9, 
                          option = "D") +
    theme(strip.text = element_text(margin = margin(0,0,0,b=6)))

# invasion_moveN_p <- invasion_move_p_df %>%
#     filter(spp == "invader") %>% 
#     ggplot(aes(distance, mvmt_N)) +
#     geom_line(data = invasion_move_p_df %>% 
#                    filter(spp != "invader"),
#                aes(group = spp, color = N0),  alpha = 0.5, size = 0.5) +
#     geom_point(shape = 1, color = "dodgerblue") +
#     facet_wrap(~ which_pt, nrow = 1) +
#     scale_y_continuous(expression(italic(Delta * "N")),
#                        breaks = c(0, 0.2, 0.4)) +
#         scale_x_continuous("Starting distance from equilibrium trait state",
#                        breaks = c(0, 0.4, 0.8, 1.2)) +
#     scale_color_viridis_c(expression(N[0]), begin = 0.1, end = 0.9, option = "D")

invasion_moveV_p <- invasion_move_p_df %>%
    mutate(id = ifelse(spp == "invader", spp, "native")) %>% 
    filter(id == "invader") %>% 
    ggplot(aes(distance, mvmt_V)) +
    geom_line(data = invasion_move_p_df %>% 
                  mutate(id = ifelse(spp == "invader", spp, "native"),
                         grp = interaction(spp, which_pt)) %>% 
                  filter(spp != "invader"),
              aes(group = grp, color = N0),  alpha = 0.5, size = 0.5) +
    geom_point(shape = 1, color = "dodgerblue") +
    facet_wrap(~ id, nrow = 1, scales =  "free_y") +
    scale_y_continuous(expression(italic(Delta * "V")),
                       breaks = scales::breaks_extended(4)) +
    scale_x_continuous("Starting distance from equilibrium trait state",
                       breaks = c(0, 0.4, 0.8, 1.2)) +
    scale_color_viridis_c(expression(N[0]), 
                          begin = 0.1, end = 0.9, option = "D") +
    theme(axis.title.x = element_text(margin = margin(0,0,0,t=12)),
          strip.text = element_text(margin = margin(0,0,0,b=6)))




invasion_p <- ggarrange(invasion_hm_p, 
                        invasion_moveN_p + theme(axis.title.x = element_blank()), 
                        invasion_moveV_p,
                        heights = c(0.5, 0.25, 0.25), 
                        ncol = 1, labels = LETTERS[1:3],
                        label.args = list(gp = gpar(fontsize = 14, 
                                                    fontface =  "plain"),
                                          vjust = 2, hjust = -4))


if (.RESAVE_PLOTS) save_plot(invasion_p, 6, 6, "3-")



# C <- matrix(0.2, .q, .q)
# diag(C) <- 1
# .p <- 0.1
# .max_t <- 5e3L
# .V1 <- 0
# .V2 <- 1.5
# .V3 <- 0
# 
# Z <- quant_gen(q = .q, eta = C, d = ds, max_t = .max_t, n_reps = 1,
#           save_every = 1L, n = 2, 
#           N0 = c(10.9196300066, 10.9196300066 * .p),
#           V0 = list(cbind(0, 0, 2), cbind(.V1, .V2, .V3)),
#           start_t = 0, perturb_sd = 0,
#           show_progress = FALSE) %>%
#     .[["nv"]] %>%
#     mutate(trait = paste0("V", trait)) %>%
#     spread(trait, value) %>%
#     mutate(spp = factor(spp, levels = 1:2, labels = c("native", "invader")))
# 
# Z %>% filter(time == max(time))
# 
# Z %>% 
#     ggplot(aes(time, N, color = spp)) +
#     geom_line() +
#     scale_y_continuous("N", limits = c(0, 11))



```






## 4. Conditional coexistence

In the simulations above, we found that with random starting trait values,
only one trait being conflicting causes total exclusion to occur.
In this section, I show that non-random patterns of starting trait values
can result in coexistence.
Specifically, coexistence will occur despite a conflicting trait if all 
species start outside the basin of attraction for the state at which 
the conflicting trait is maximized.
In these simulations, the first trait is conflicting and the others 
are non-conflicting.
We start the communities with 100 species.
One simulation gives these species random trait values
($\mathbf{V} \sim |\text{N}(0,2)|$).
In the other simulation, we forced starting trait 1 to be less than trait 2 
for all species ($\mathbf{v}_1 \sim |\text{N}(0,2)|$ and 
$\mathbf{v}_2 \sim \text{U}(0, \mathbf{v}_2)$).
This kept all species outside the basin of attraction for the conflicting trait.
We kept trait 3 at zero for all simulations, for the reasons outlined in 
the last section.
We kept track of abundances and trait values through time for all species.



When simulations started with a population whose trait values were all in the 
basin of attraction for a non-conflicting trait, species evolve towards the 
adaptive peak for the non-conflicting trait---and can coexist with one another
(Figure 4). 
When the population starts with some species in the basin of attraction for 
the conflicting trait, those species evolve towards that adaptive peak, and 
the one that reaches the peak first excludes all other species.




```{r cond_coex-caption}
cc_cap <- "Figure 4.
           Two simulations illustrating conditional coexistence for a mix of both conflicting and non-conflicting traits. 
           The left panels show exclusion, whereas the right two show 
           conditional coexistence. 
           In the top two panels, each line is for a particular species. 
           In the bottom two panels, circles show starting trait values, 
           and lines show trajectories through trait space through time.
           Xs show the trait values for surviving species. 
           The gray area is the basin of attraction for the 
           non-conflicting trait.
"
```

```{r cond_coex-results, fig.cap = cc(cc_cap), fig.width=5, fig.height=5}

# d_sim_df %>% distinct(d1, d2, d3)



set.seed(1245262468)
V0_coexist <- lapply(1:100,
                     function(i) {
                         V0 <- rbind(numeric(3))
                         V0[,2] <- abs(rnorm(1, 0, 2))
                         V0[,1] <- runif(1) * V0[,2]
                         return(V0)
                     })
V0_exclude <- lapply(1:100,
                     function(i) {
                         V0 <- rbind(abs(rnorm(3, 0, 2)))
                         V0[,3] <- 0
                         return(V0)
                     })


cond_coexist_test <- function(.V0, .lab) {
    Z <- quant_gen(q = .q, eta = 0.2, d = ds*c(-1,1,1), max_t = 20e3L, n_reps = 1,
                   save_every = 10L, n = 100, N0 = rep(1, 100),
                   V0 = .V0,
                   start_t = 0, perturb_sd = 0,
                   show_progress = FALSE) %>%
        .[["nv"]] %>%
        mutate(trait = paste0("V", trait)) %>%
        spread(trait, value) %>%
        select(-rep) %>%
        mutate(V0 = .lab)
    return(Z)
}



# Just takes a few seconds
cond_coexist_df <- tibble(.V0 = list(V0_coexist, V0_exclude),
                          .lab = c("exclusion", "coexistence")) %>%
    pmap_dfr(cond_coexist_test) %>% 
    mutate(V0 = factor(V0, levels = c("exclusion", "coexistence")))




# Time series for coexistence and exclusion
cond_coexist_ts_p <- cond_coexist_df %>%
    ggplot(aes(time, N, color = spp)) +
    geom_line(alpha = 0.5) +
    facet_wrap(~ V0, scales = "free") +
    scale_color_viridis_d(begin = 0.1, end = 0.9, option = "C", guide = FALSE) +
    ylab("Abundance") +
    scale_x_continuous("Time", breaks = seq(0, 20e3, 5e3),
                       labels = format(seq(0, 20e3, 5e3), big.mark = ",")) +
    theme(strip.text = element_text(size = 12, margin = margin(0,0,0,b = 24)))


# Movement through trait space for coexistence and exclusion:
cond_coexist_sp_p <- cond_coexist_df %>%
    arrange(time, spp) %>%
    ggplot(aes(V1, V2, color = spp)) +
    # geom_abline(slope = 1, intercept = 0, linetype = 2, color = "gray70") +
    geom_polygon(data = tibble(x = c(-1, 5, -1), y = c(-1, 5, 5)), aes(x,y),
                 color = NA, fill = "gray80") +
    geom_path(alpha = 0.5) +
    geom_point(data = cond_coexist_df %>% filter(time == min(time)),
               shape = 1) +
    geom_point(data = cond_coexist_df %>% filter(time == max(time)) %>%
                   group_by(V0) %>%
                   filter(unq_spp_filter(V1, V2)) %>%
                   ungroup(),
               shape = 4, size = 4, color = "black") +
    scale_color_viridis_d(begin = 0.1, end = 0.9, option = "C", guide = FALSE) +
    facet_wrap(~ V0) +
    coord_equal(xlim = c(0, 4.25), ylim = c(0, 4.25)) +
    ylab("Trait 2") +
    xlab("Trait 1") +
    theme(strip.text = element_blank())





cond_coexist_p <- ggarrange(cond_coexist_ts_p, 
                            cond_coexist_sp_p, 
                            heights = c(0.5, 0.5),
                            ncol = 1, labels = LETTERS[1:2],
                            label.args = list(gp = gpar(fontsize = 14,
                                                        fontface =  "plain"),
                                              vjust = 2, hjust = -5))


if (.RESAVE_PLOTS) save_plot(cond_coexist_p, 5, 5, "4-")


```
