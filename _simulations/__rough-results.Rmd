---
title: "Results"
author: "Lucas A. Nell"
date: ""
output: word_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, eval = TRUE}

# RUN THIS INSTEAD OF USING CMD-SHIFT-K IN RSTUDIO:
# rmarkdown::render("_simulations/__rough-results.Rmd")

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, 
                      eval = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))

# load packages
suppressPackageStartupMessages({
    library(sauron)
    library(tidyverse)
    library(grid)
    library(parallel)
    library(cowplot)
    library(egg)
})

# This sets plotting device on LAN computer:
if (!isTRUE(getOption('knitr.in.progress')) && file.exists(".Rprofile")) {
  source(".Rprofile")
}


# Clean captions
cc <- function(.x) {
    .x <- gsub("\n", "", .x)
    .x <- gsub("\\s+", " ", .x)
    return(.x)
}

# whether to re-do simulations (use rds files otherwise)
.REDO_SIMS <- FALSE
# whether to re-save plots
.RESAVE_PLOTS <- FALSE
# number of threads to use for simulations
.N_THREADS <- 2



# Where to save rds files
rds <- function(.x) {
    sprintf("~/GitHub/Wisconsin/sauron/_simulations/__rough-results/%s.rds",
           gsub("\\.rds$", "", gsub("^\\/", "", .x)))
}



save_plot <- function(plot_obj, .width, .height, .prefix = NULL, .suffix = NULL) {
    fn <- gsub("_p$", "", paste(substitute(plot_obj)))
    if (!is.null(.prefix)) fn <- paste0(.prefix, fn)
    if (!is.null(.suffix)) fn <- paste0(fn, .suffix)
    fn <- sprintf("_simulations/__rough-results/%s.pdf", fn)
    cat(fn, "\n")
    plot_fun <- ifelse(inherits(plot_obj, "egg"), print, plot)
    cairo_pdf(fn, width = .width, height = .height)
    plot_fun(plot_obj)
    dev.off()
    invisible(NULL)
}

unq_spp_filter <- function(..., .prec = 0.001) {
    V <- list(...)
    V <- do.call(cbind, V)
    V <- split(V, row(V))
    return(as.logical(sauron:::unq_spp_cpp(V, precision = .prec)))
}

group_spp <- function(..., .prec = 0.001) {
    V <- list(...)
    V <- do.call(cbind, V)
    V <- split(V, row(V))
    return(sauron:::group_spp_cpp(V, precision = .prec))
}


.q <- 3

```


## 1. Trait outcomes

```{r trait-outcomes-sims}

set.seed(1652339501)
etas <- runif(.q * ((.q - 1) / 2), 0.1, 0.4)



one_eta_combo <- function(sign1, sign2, sign3) {
  
    # sign1 = 1; sign2 = 1; sign3 = 1
    # rm(sign1, sign2, sign3)

    C <- matrix(0, .q, .q)
    C[lower.tri(C)] <- abs(etas) * c(sign1, sign2, sign3)
    # sample(c(-1, 1), .q, TRUE)
    C <- C + t(C)
    diag(C) <- 1

    trait_to <- quant_gen(q = .q, eta = C, d = 0.1, max_t = 20e3L, n_reps = 24,
                          save_every = 0L, n = 100, N0 = rep(1, 100),
                          start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
                          show_progress = FALSE)
    
    output <- list(jacs = jacobians(trait_to),
                   ts = trait_to$nv %>%
                       mutate(trait = paste0("V", trait)) %>%
                       spread(trait, value) %>%
                       filter(unq_spp_filter(V1, V2, V3)) %>%
                       select(starts_with("V")) %>%
                       mutate(eta1 = C[2,1], eta2 = C[3,1], eta3 = C[3,2]))
    return(output)
}


if (.REDO_SIMS) {
    # Takes ~6 min with 2 threads
    set.seed(145746935)
    eta_sims <- crossing(sign1 = -1:1, sign2 = -1:1, sign3 = -1:1) %>%
        pmap(one_eta_combo)
    saveRDS(eta_sims, rds("eta_sim"))
} else {
    eta_sims <- readRDS(rds("eta_sim"))
}
eta_sim_df <- map_dfr(eta_sims, ~.x$ts)
# eta_sim_jacs <- do.call(c, map(eta_sims, ~.x$jacs))
# 
# 
# # These eigenvalues show that any points with a trait equal to zero aren't 
# # stable. This is because we're forcing them to be >= 0, not doing it
# # mathematically in the equations themselves.
# eta_sim_eigs <- crossing(sign1 = -1:1, sign2 = -1:1, sign3 = -1:1, 
#                          rep = 1L:24L) %>%
#     mutate(eigen = map_dbl(eta_sim_jacs, ~ max(eigen(.x)$values)))
# 
# eta_sim_eigs %>% 
#     group_by(sign1, sign2, sign3) %>% 
#     summarize(e_min = min(eigen),
#               e_max = max(eigen)) %>% 
#     ungroup() %>% 
#     as.data.frame()

```


With three traits, we first generated the 3 $\eta$ magnitudes from a
uniform distribution from 0.1 to 0.4.
The values we ended up with were 
$\eta_1 = 0.207$, $\eta_2 = 0.190$, and $\eta_3 = 0.257$. 
We then simulated communities of 100 species, each with random starting
trait values ($\sim \text{N}(0, 2)$, truncated to be $\ge 0$).
We did this 24 times for each of the 27 permutations of 
$\eta_1$, $\eta_2$, and $\eta_3$ being negative, zero, or positive.
Because we were only interested in the possible trait values for surviving
species, we set $d = 0.1$ (non-conflicting evolution) so that many species 
survived and surveyed the trait space more effectively.
We recorded the trait values of the surviving species.


This resulted in a number of outcomes (Figure 1).
When at least one combination was sub-additive, only one set of trait 
values were present in surviving species.
What those trait values were depended on the exact combination.
With all sub-additive combinations, all three traits were maximized.
The six other permutations of $\ge 2$ sub-additive combinations varied but 
all had high values of $\eta_2$ and usually had high values of $\eta_3$.
With only one sub-additive combination, the combination that was sub-additive
determined which of the three trait states the surviving species possessed.


We observed alternative trait states only when no trait combinations 
were sub-additive.
When all combinations were super-additive, there were three alternative 
trait states: one for each trait being maximized while the others 
equaled zero.
With two super-additive and one neutral combinations, species traits were 
along a neutrally stable quarter-ring along one axis.
With one super-additive and two neutral combinations, species traits were 
along a neutrally stable half-ring along two axes.
Traits existed along a neutrally stable three-dimensional shell when all 
traits were neutral.



__NOTE:__ When $d$ is large enough ($d = 0.9$ does it for these parameter values),
you can get additional trait outcomes.
In some cases, it adds 1 or 2 additional trait state(s), but in the case
of 1 sub-additive, 1 neutral, and 1 super-additive trait (i.e., "1 of each"),
it allows for many possibilities:
anywhere on a sub-section of the neutral ring (like
the "2 super, 1 neutral" scenario, but even more reduced).
The species that exist at these additional trait states 
have at least slightly lower densities than the others at the trait state
that exists when $d = 0.1$.
Is this interesting or likely an artifact?


```{r trait-outcomes-caption}
to_cap <- "Figure 1.
           Unique trait values for surviving species, for all 27 combinations
           of pairwise combinations of traits being 
           sub-additive ($\\eta < 0$ or \"$-$\"), neutral ($\\eta = 0$), 
           or super-additive ($\\eta > 0$ or \"$+$\").
           The size of points indicates the value for trait 3.
           Sub-panels separate the number of pairwise combinations (out of 3)
           that are sub-additive, neutral, or super-additive.
           All but the \"all super\" and \"all neutral\" sub-panels 
           contain multiple pairwise combinations, so each specific combination 
           is separated by color and indicated by the colored label.
           The symbol $0^{+}$ inside labels indicates when that $\\eta$ can be
           $\\ge 0$.
           Therefore, all 3 points in the \"1 sub\" sub-panel represent 
           4 combinations each.
           When one sub-panel contains multiple points of the same color, 
           this indicates that multiple alternative states are possible
           for that combination."
```

```{r trait-outcomes-results, fig.cap = cc(to_cap), fig.width=6, fig.height=5}


### The code below explores what happens when d >= 0.9
#
# eta_sim_df %>% 
#     filter((eta1 < 0 & eta2 == 0 & eta3 > 0) |
#                (eta1 < 0 & eta2 > 0 & eta3 == 0) |
#                (eta1 == 0 & eta2 < 0 & eta3 > 0) |
#                (eta1 == 0 & eta2 > 0 & eta3 < 0) |
#                (eta1 > 0 & eta2 == 0 & eta3 < 0) |
#                (eta1 > 0 & eta2 < 0 & eta3 == 0)) %>% 
#     group_by(eta1, eta2, eta3) %>% 
#     summarize(N = n()) %>% 
#     ungroup()
# 
# 
# sign1 = -1; sign2 = -1; sign3 = 1
# C <- matrix(0, .q, .q)
# C[lower.tri(C)] <- abs(etas) * c(sign1, sign2, sign3)
# # sample(c(-1, 1), .q, TRUE)
# C <- C + t(C)
# diag(C) <- 1
# 
# trait_to <- quant_gen(q = .q, eta = C, d = 0.9, max_t = 20e3L, n_reps = 24,
#                       save_every = 100L, n = 100, N0 = rep(1, 100),
#                       start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
#                       show_progress = TRUE)
# 
# trait_to$nv %>%
#     filter(time == max(time)) %>% 
#     mutate(trait = paste0("V", trait)) %>%
#     spread(trait, value) %>%
#     filter(unq_spp_filter(V1, V2, V3)) %>%
#     select(starts_with("V")) %>%
#     mutate(eta1 = C[2,1], eta2 = C[3,1], eta3 = C[3,2])
# 
# trait_to$nv %>%
#     filter(time == max(time)) %>% 
#     mutate(trait = paste0("V", trait)) %>%
#     spread(trait, value) %>%
#     # filter(unq_spp_filter(V1, V2, V3)) %>%
#     # select(starts_with("V")) %>%
#     filter(!((V1 - 1.63)^2 < 0.001 & (V2 - 1.63)^2 < 0.001 & V3 == 0)) %>% 
#     .[["N"]] %>% 
#     range()
# 
# 
# 
# 
# # # A tibble: 1 x 6
# #      V1    V2    V3   eta1  eta2  eta3
# #   <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>
# # 1  1.63  1.63     0 -0.207     0 0.257
# 
# 
# trait_to$nv %>% 
#     filter(trait == 1, rep == 1) %>% 
#     filter(time == max(time))
#     # filter(time < 1000) %>% 
#     ggplot(aes(time, N)) +
#     geom_line(aes(color = spp)) +
#     scale_color_viridis_d(guide = FALSE)
# 
# 





# This function combines id labels for all combinations that have the exact 
# same outcomes. Only used for "1 sub".
# It also processes all id columns to be parsed.
process_ids <- function(z) {
    
    parseable <- function(.id) {
        .id = paste(.id)
        IDD1 = str_sub(.id, 1, 1) %>% 
            {case_when(. == "+" ~ paste0("{}", .),
                       . == "-" ~ paste0(., "''"),
                       . == "0" ~ "0",
                       . == "X" ~ "0^{'+'}",
                       TRUE ~ NA_character_)}
        IDD2 = str_sub(.id, 2, 2) %>% 
            {case_when(. == "-" ~ paste0(., "''"), 
                       . == "X" ~ "0^{'+'}",
                       TRUE ~ .)}
        IDD3 = str_sub(.id, 3, 3) %>% 
            {case_when(. == "+" ~ paste0(., "{}"),
                      . == "-" ~ paste0(., "''"),
                      . == "0" ~ "0",
                      . == "X" ~ "0^{'+'}",
                      TRUE ~ NA_character_)}
        if(any(is.na(IDD1)) || any(is.na(IDD3))) {
            print(.id[is.na(IDD1) | is.na(IDD3)])
            stop("Non-programmed option in `parseable`")
        }
        paste0(IDD1, IDD2, IDD3) %>% 
            str_replace_all("''0", "0") %>% 
            str_replace_all("\\{\\}0", "0") %>% 
            str_replace_all("\\}0", "\\} * 0") %>% 
            str_replace_all("00", "0 * 0") %>% 
            str_replace_all("00", "0 * 0")
    }
    

    if (z$p_groups[1] != "'1 sub'") return(mutate(z, id = parseable(id)))
    
    one_chr <- function(.x) {
        .xx <- .x %>% 
            str_split("") %>% 
            {lapply(1:length(.[[1]]), function(i) map_chr(., ~ .x[[i]]))} %>% 
            map_chr(function(x) {
                xx <- unique(x)
                if (length(xx) == 1) return(xx)
                if (all(xx %in% c("0", "+"))) return("X")
                return(NA_character_)
            })
        if (any(is.na(.xx))) stop("Non-programmed input to `one_chr`")
        return(paste(.xx, collapse = ""))
    }

    z %>%
        mutate(color_group = group_spp(V1, V2, V3) + 1L) %>%
        mutate_at(vars(id), paste) %>% 
        arrange(p_groups, color_group) %>%
        group_by(p_groups, color_group) %>%
        summarize(V1 = mean(V1),
                  V2 = mean(V2),
                  V3 = mean(V3),
                  id = one_chr(id)) %>%
        ungroup() %>%
        mutate(id = parseable(id))

}

p_group_levels <- c("{} >= '2 sub'", "'1 sub'",
                    "'all super'",
                    "'2 super, 1 neutral'", "'2 neutral, 1 super'", 
                    "'all neutral'")


trait_outcomes_p_df <- eta_sim_df %>%
    mutate_at(vars(starts_with("eta")),
              ~ factor(sign(.x), levels = -1:1, labels = c("-", "0", "+"))) %>%
    mutate(id = interaction(eta1, eta2, eta3, sep = "")) %>%
    group_by(id) %>%
    filter(unq_spp_filter(V1, V2, V3, .prec = 0.1)) %>%
    ungroup() %>%
    mutate(n_p = str_count(id, "\\+"),
           n_n = str_count(id, "\\-"),
           n_z = str_count(id, "0"),
           p_groups = case_when(n_n >= 2 ~ p_group_levels[1],
                                n_n == 1  ~ p_group_levels[2],
                                n_p == 3 ~ p_group_levels[3],
                                n_p == 2 & n_z == 1 ~ p_group_levels[4],
                                n_z == 2 & n_p == 1 ~ p_group_levels[5],
                                n_z == 3 ~ p_group_levels[6],
                                TRUE ~ NA_character_)) %>%
    select(-starts_with("n", ignore.case = FALSE)) %>%
    # filter(is.na(p_groups))  ## <-- check that this yields no rows
    mutate(p_groups = factor(p_groups, levels = p_group_levels)) %>%
    arrange(p_groups) %>% 
    split(.$p_groups) %>%
    map(~ mutate(.x, color_group = id %>% droplevels() %>% as.integer())) %>%
    map_dfr(process_ids) %>%
    mutate_at(vars(color_group, id), factor) %>%
    arrange(desc(V3))



.pal <- function(.a = 1) viridisLite::plasma(7, end = 0.85, 
                                             alpha = .a)[c(6,4,1,3,5,7,2)]


trait_outcomes_p <- trait_outcomes_p_df %>%
    ggplot(aes(V1, V2, size = V3, color = color_group)) +
    geom_point(aes(fill = color_group), shape = 21) +
    geom_text(data = trait_outcomes_p_df %>%
                  filter(!grepl("^\\'all", p_groups)) %>%
                  group_by(p_groups, color_group, id) %>%
                  summarize_at(vars(V1, V2), median) %>%
                  ungroup() %>% 
                  mutate(V1 = case_when(id == "{}+0+{}" ~ V1 - 0.3,
                                        id == "0 * 0+{}" ~ V1 - 0.3,
                                        id == "{}+0 * 0" ~ V1 - 0.1,
                                        id == "0-''-''" ~ V1 - 0.4,
                                        id == "-''-''+{}" ~ V1 - 0.1,
                                        id == "{}+-''-''" ~ V1 - 0.3,
                                        id == "-''+-''" ~ V1 - 0.3,
                                        id == "-0-''" ~ V1 - 0.4,
                                        TRUE ~ V1),
                         V2 = case_when(id == "{}+0+{}" ~ V2 + 0.05,
                                        id == "0 * 0+{}" ~ V2 + 0.05,
                                        id == "{}+0 * 0" ~ V2 + 0.05,
                                        id == "0+0" ~ V2 - 0.05,
                                        id == "0-''-''" ~ V2 - 0.6,
                                        id == "-''-0" ~ V2 - 0.4,
                                        id == "-''-''+{}" ~ V2 - 0.3,
                                        id == "-''-''-''" ~ V2 - 0.1,
                                        id == "{}+-''-''" ~ V2 - 0.6,
                                        id == "-0-''" ~ V2 + 0.05,
                                        TRUE ~ V2)) %>%
                  identity(),
              aes(label = id), size = 9 / 2.835, hjust = 0, vjust = 0, parse = TRUE,
              fontface = "bold", lineheight = 0.75, nudge_x = 0.2, nudge_y = 0.2) +
    scale_size_continuous("Trait 3", range = c(2, 6), breaks = 0.5 * 1:3) +
    scale_x_continuous("Trait 1", breaks = 0:2) +
    scale_y_continuous("Trait 2", breaks = 0:2) +
    coord_equal(xlim = c(0, 2.5), ylim = c(0, 2.5)) +
    facet_wrap(~ p_groups, nrow = 3, labeller = label_parsed) +
    theme(strip.text = element_text(size = 10),
          panel.border = element_rect(size = 0.5, fill = NA)) +
    scale_color_manual(values = .pal(), guide = FALSE) +
    scale_fill_manual(values = .pal(0.25), guide = FALSE) +
    NULL


if (.RESAVE_PLOTS) save_plot(trait_outcomes_p, 6, 5, "1-")

trait_outcomes_p


```





## 2. Coexistence






```{r coexistence-caption}
coex_cap <- "Figure 2.
             Number of surviving species for
             (A) all permutations of three traits being conflicting (\"-\") 
             or non-conflicting (\"+\") and
             (B) varying values of $d_3$ when $d_1$ and $d_2$ are kept positive
             (i.e., traits 1 and 2 are kept non-conflicting).
             (A) Numbers above segments indicate the number of traits that are 
             non-conflicting.
             For these simulations, $\\eta_1 = \\eta_2 = \\eta_3 = 0.2$"
```

```{r coexistence-results, fig.cap = cc(coex_cap), fig.width=6.5, fig.height=5.0}

# =======================================================================================`
# =======================================================================================`

#               II. Coexistence ----

# =======================================================================================`
# =======================================================================================`


set.seed(532052696)
ds <- exp(runif(.q, -6, -2))


C <- matrix(0.2, .q, .q)
diag(C) <- 1



# ------------------------------*
# __ all combinations ----
# ------------------------------*

# All combinations of - or + d values

one_d_combo <- function(sign1, sign2, sign3) {

    .d <- ds * c(sign1, sign2, sign3)

    Z <- quant_gen(q = .q, eta = C, d = .d, max_t = 20e3L, n_reps = 24,
              save_every = 0L, n = 100, N0 = rep(1, 100),
              start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
              show_progress = FALSE)

    Z$nv %>%
        mutate(trait = paste0("V", trait)) %>%
        spread(trait, value) %>%
        # filter(unq_spp_filter(V1, V2, V3)) %>%
        mutate(d1 = .d[1], d2 = .d[2], d3 = .d[3])

}

# Takes ~45 sec w/ 2 threads
set.seed(751678518)
d_sim_df <- crossing(sign1 = c(-1,1), sign2 = c(-1,1), sign3 = c(-1,1)) %>%
    pmap_dfr(one_d_combo)


lab_df <- tibble(idd = c(1, 2, 5, 8) - 0.25, idd_e = c(1, 4, 7, 8) + 0.25,
                 N = c(rep(10, 3), 50),
                 lab = sprintf("%i", 0:3))

coexist_all_d_p <- d_sim_df %>%
    group_by(d1, d2, d3, rep) %>%
    summarize(N = n()) %>%
    ungroup() %>%
    mutate_at(vars(starts_with("d")),
              ~ factor(sign(.x), levels = c(-1,1), labels = c("-", "+"))) %>%
    mutate(id = interaction(d1, d2, d3, sep = "{}"),
           id = factor(id, levels = levels(id),
                       labels = sprintf("%s{}", levels(id))),
           n_p = str_count(id, "\\+"),
           idd = interaction(n_p, id, sep = "", lex.order = TRUE, drop = TRUE),
           idd = factor(idd, levels = levels(idd),
                        labels = gsub("0|1|2|3", "", levels(idd)))) %>%
    ggplot(aes(idd, N)) +
    geom_jitter(width = 0.25, alpha = 0.5, height = 0, 
                color = "dodgerblue4", fill = "dodgerblue", shape = 21) +
    geom_segment(data = lab_df, aes(xend = idd_e, yend = N)) +
    geom_text(data = lab_df, aes(x = (idd + idd_e) / 2, y = N + 2, label = lab),
              hjust = 0.5, vjust = 0) +
    # facet_wrap(~ n_p, scales = "free_x") +
    scale_y_continuous("Number of surviving species", limits = c(0, 55),
                       breaks = c(0, 25, 50)) +
    scale_x_discrete(expression("Sign of" ~ d[1] * "," ~ d[2] * "," ~ d[3]),
                     labels = rlang::parse_exprs) +
    scale_color_viridis_d(guide = FALSE, end = 0.8, option = "B") +
    theme(strip.text = element_text(size = 8),
          axis.text.x = element_text(size = 11)) +
    NULL




# ------------------------------*
# __ slowly vary 1 ----
# ------------------------------*

# Keep 2 d values positive, make the last one go slowly negative

one_d_combo_vary_one <- function(.d3, .max_t) {

    .d <- c(0.1, 0.1, .d3)

    Z <- quant_gen(q = .q, eta = C, d = .d, max_t = .max_t, n_reps = 24,
                   save_every = 0L, n = 100, N0 = rep(1, 100),
                   start_t = 0, perturb_sd = 2, n_threads = .N_THREADS,
                   show_progress = FALSE)

    Z$nv %>%
        spread(trait, value) %>%
        group_by(rep) %>%
        summarize(n_spp = n()) %>%
        ungroup() %>%
        mutate(d3 = .d3) %>%
        identity()

}


if (.REDO_SIMS) {
    # Takes ~30 min
    set.seed(807582316)
    one_d_sim_df <- tibble(.d3 = c(-10^(c(-2, -3, -4)), 0, 10^(c(-4, -3, -2))),
                        .max_t = 200e3L) %>%
        mutate(.max_t = ifelse(.d3 == -1e-4, 2e6L, .max_t)) %>%
        pmap_dfr(one_d_combo_vary_one)
    saveRDS(one_d_sim_df, rds("one_d_sim"))
} else {
    one_d_sim_df <- readRDS(rds("one_d_sim"))
}




lab_fun <- function(.x) {
    labs <- paste(.x)
    labs[.x != 0] <- sprintf("%s10^{%i}",
                             sign(.x[.x != 0]) %>% paste() %>% str_remove("1"),
                             abs(.x[.x != 0]) %>% log10())
    return(labs)
}

coexist_one_d_p <- one_d_sim_df %>%
    mutate(d3 = factor(d3, levels = d3 %>% sort() %>% unique(),
                       labels = d3 %>% sort() %>% unique() %>% lab_fun())) %>%
    ggplot(aes(d3, n_spp)) +
    geom_jitter(width = 0.2, alpha = 0.5, height = 0, 
                color = "dodgerblue4", fill = "dodgerblue", shape = 21) +
    scale_color_viridis_d(guide = FALSE, end = 0.95, option = "D") +
    scale_x_discrete(expression("Value of" ~ d[3]), labels = rlang::parse_exprs) +
    scale_y_continuous("Number of surviving species", breaks = c(0, 25, 50),
                       limits = c(0, 55)) +
    NULL




# ------------------------------*
# __ combine them ----
# ------------------------------*



coexist_p <- ggarrange(coexist_all_d_p + theme(axis.title.y = element_blank()), 
                       coexist_one_d_p + theme(axis.title.y = element_blank()), 
                       left = "Number of surviving species",
                       ncol = 1, labels = LETTERS[1:2],
                       label.args = list(gp = gpar(fontsize = 14, 
                                                   fontface =  "plain"),
                                         vjust = 2, hjust = -3))


if (.RESAVE_PLOTS) save_plot(coexist_p, 6.5, 6, "2-")

```





## 3. Invasibility


```{r invasibility-caption}
inv_cap <- "Figure 3.
             XX.
"
```

```{r invasibility-results, fig.cap = cc(inv_cap), fig.width=6.5, fig.height=3}



invade_test <- function(r, .V1, .V2, .dsigns, .V3 = 0) {
    Z <- quant_gen(q = .q, eta = C, d = ds*.dsigns, max_t = 20e3L, n_reps = 1,
                   save_every = 100L, n = 2, N0 = c(10.9196300066, 10.9196300066 * 0.1),
                   V0 = list(cbind(2, 0, 0), cbind(.V1, .V2, .V3)),
                   start_t = 0, perturb_sd = 0,
                   show_progress = FALSE) %>%
        .[["nv"]] %>%
        mutate(trait = paste0("V", trait)) %>%
        spread(trait, value) %>%
        mutate(spp = factor(spp, levels = 1:2, labels = c("native", "invader")),
               rep = paste(.V1, .V2, .V3, sep = "__"),
               dsigns = paste(.dsigns, collapse = "__"))
    return(Z)
}


if (.REDO_SIMS) {
    # Takes ~2 min
    invade_df <- crossing(.V1 = seq(0, 4, 0.1),
                          .V2 = seq(0, 4, 0.1),
                          .dsigns = list(c(-1,1,1), c(1,1,1))) %>%
        mutate(r = 1:n()) %>%
        pmap_dfr(invade_test)
    saveRDS(invade_df, rds("invade"))
} else {
    invade_df <- readRDS(rds("invade"))
}





invasion_p_df <- invade_df %>%
    mutate(dsigns = factor(dsigns, levels = c("-1__1__1", "1__1__1"),
                           labels = c("-{}+{}+{}", "+{}+{}+{}"))) %>%
    group_by(dsigns, rep) %>%
    summarize(invaded = factor(sum(time == max(time) & spp == "invader"),
                               levels = 0:1, labels = c("no", "yes")),
              V1 = str_split(rep, "__")[[1]][[1]] %>% as.numeric(),
              V2 = str_split(rep, "__")[[1]][[2]] %>% as.numeric()) %>%
    ungroup() %>%
    select(-rep)


invasion_p <- invasion_p_df %>%
    ggplot(aes(V1, V2)) +
    geom_tile(aes(fill = invaded)) +
    geom_point(data = tibble(V1 = c(0, 2, 2), V2 = c(2, 0, 0),
                             dsigns = c("+{}+{}+{}", "+{}+{}+{}", "-{}+{}+{}")),
               size = 4, color = "black", shape = 4) +
    facet_wrap(~ dsigns, labeller = label_parsed, nrow = 1) +
    xlab("Invader trait 1") +
    ylab("Invader trait 2") +
    scale_fill_viridis_d("successful", begin = 0.3, end = 0.9, option = "C") +
    coord_equal()



if (.RESAVE_PLOTS) save_plot(invasion_p, 6.5, 3, "3-")


invasion_p

```






## 4. Conditional coexistence

```{r cond_coex-caption}
cc_cap <- "Figure 4.
             XX.
"
```

```{r cond_coex-results, fig.cap = cc(cc_cap), fig.width=5, fig.height=5}

# d_sim_df %>% distinct(d1, d2, d3)

d_sim_df %>%
    filter(d1 < 0, d2 > 0, d3 > 0, rep == 1) %>%
    select(-starts_with("d"), -rep) %>%
    .[["N"]]


set.seed(1245262468)
V0_coexist <- lapply(1:100,
                     function(i) {
                         V0 <- rbind(numeric(3))
                         V0[,2] <- abs(rnorm(1, 0, 2))
                         V0[,1] <- runif(1) * V0[,2]
                         return(V0)
                     })
V0_exclude <- lapply(1:100,
                     function(i) {
                         V0 <- rbind(abs(rnorm(3, 0, 2)))
                         V0[,3] <- 0
                         return(V0)
                     })


cond_coexist_test <- function(.V0, .lab) {
    Z <- quant_gen(q = .q, eta = C, d = ds*c(-1,1,1), max_t = 20e3L, n_reps = 1,
                   save_every = 10L, n = 100, N0 = rep(1, 100),
                   V0 = .V0,
                   start_t = 0, perturb_sd = 0,
                   show_progress = FALSE) %>%
        .[["nv"]] %>%
        mutate(trait = paste0("V", trait)) %>%
        spread(trait, value) %>%
        select(-rep) %>%
        mutate(V0 = .lab)
    return(Z)
}



# Just takes a few seconds
cond_coexist_df <- tibble(.V0 = list(V0_coexist, V0_exclude),
                          .lab = c("coexistence", "exclusion")) %>%
    pmap_dfr(cond_coexist_test)




# Time series for coexistence and exclusion
cond_coexist_ts_p <- cond_coexist_df %>%
    ggplot(aes(time, N, color = spp)) +
    geom_line(alpha = 0.5) +
    facet_wrap(~ V0, scales = "free") +
    scale_color_viridis_d(begin = 0.1, end = 0.9, option = "C", guide = FALSE) +
    ylab("Abundance") +
    scale_x_continuous("Time", breaks = seq(0, 20e3, 5e3),
                       labels = format(seq(0, 20e3, 5e3), big.mark = ",")) +
    theme(strip.text = element_text(size = 12, margin = margin(0,0,0,b = 24)))


# Movement through trait space for coexistence and exclusion:
cond_coexist_sp_p <- cond_coexist_df %>%
    arrange(time, spp) %>%
    ggplot(aes(V1, V2, color = spp)) +
    # geom_abline(slope = 1, intercept = 0, linetype = 2, color = "gray70") +
    geom_polygon(data = tibble(x = c(-1, 5, -1), y = c(-1, 5, 5)), aes(x,y),
                 color = NA, fill = "gray80") +
    geom_path(alpha = 0.5) +
    geom_point(data = cond_coexist_df %>% filter(time == min(time)),
               shape = 1) +
    geom_point(data = cond_coexist_df %>% filter(time == max(time)) %>%
                   group_by(V0) %>%
                   filter(unq_spp_filter(V1, V2)) %>%
                   ungroup(),
               shape = 4, size = 4, color = "black") +
    scale_color_viridis_d(begin = 0.1, end = 0.9, option = "C", guide = FALSE) +
    facet_wrap(~ V0) +
    coord_equal(xlim = c(0, 4.25), ylim = c(0, 4.25)) +
    ylab("Trait 2") +
    xlab("Trait 1") +
    theme(strip.text = element_blank())





cond_coexist_p <- plot_grid(cond_coexist_ts_p, cond_coexist_sp_p, ncol = 1,
                            rel_heights = c(0.85, 1), labels = LETTERS[1:2],
                            label_y = c(0.83,1))


if (.RESAVE_PLOTS) save_plot(cond_coexist_p, 5, 5, "4-")

cond_coexist_p

```
