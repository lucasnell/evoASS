---
title: "Simulations"
author: "Lucas A. Nell"
date: "10/25/2018"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulations}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4,
  echo = FALSE,
  eval = TRUE
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
if (!isTRUE(getOption('knitr.in.progress'))) options(tibble.print_min = 16L, tibble.print_max = 16L)
suppressPackageStartupMessages({
    library(tidyverse)
    library(sauron)
})
```
```{r get-sim-info}
# Function to get the relevant rds file for a given simulation scenario:
get_sim <- function(eta_sign, d_sign, q) {
    return(readRDS(sprintf("results/q%i/%s-eta_%s-d.rds", q, eta_sign, d_sign)))
}
# Takes ~ 1 min
sims2 <- map2(rep(1:3, each = 3), rep(1:3, 3), 
              function(e, d, .q) {
                  chrs <- c("n", "z", "p")
                  qg_ <- get_sim(chrs[e], chrs[d], .q)
                  qg_$nv <- qg_$nv %>% filter(time == max(time))
                  return(qg_)
              }, .q = 2)
sims3 <- map2(rep(1:3, each = 3), rep(1:3, 3), 
              function(e, d, .q) {
                  chrs <- c("n", "z", "p")
                  qg_ <- get_sim(chrs[e], chrs[d], .q)
                  qg_$nv <- qg_$nv %>% filter(time == max(time))
                  return(qg_)
              }, .q = 3)
```


## Doing and saving simulations

```{r do_sims, echo = TRUE}
# Create list for running a set of simulations:
quant_gen_pars <- function(eta_sign, d_sign, q, n = 100) {
    # Other parameter values that I'll keep constant:
    args <- list(
        n_reps = 100,
        V0 = rep(list(matrix(0, 1, q)), n),
        N0 = rep(1, n),
        f = 0.1,  # cost of the trait on the growth rate
        g = 0.5,  # benefit of the trait on density dependence
        r0 = 0.5,
        add_var = rep(0.5, n),
        mut_sd = 1,
        keep_pos = FALSE,
        start_t = 0,
        max_t = 1e6,
        min_N = 1e-4,
        save_every = 1000,
        show_progress = TRUE,
        n_cores = 4)
    # the non-additive effects of traits on `r`:
    if (grepl("^p", eta_sign, TRUE)) {
        args$eta <- 0.01
    } else if (grepl("^z", eta_sign, TRUE)) {
        args$eta <- 0
    } else {
        args$eta <- -0.01
    }
    # changes how the focal line is affected by other lines' trait values:
    if (grepl("^p", d_sign, TRUE)) {
        args$d <- 1e-4
    } else if (grepl("^z", d_sign, TRUE)) {
        args$d <- 0
    } else {
        args$d <- -0.1
    }

    return(args)
}
```


### Two traits


```{r, run_sims_q2, eval = FALSE, echo = TRUE}
# Takes ~ 2.1 hrs
set.seed(2028111205)
seeds <- sample.int(.Machine$integer.max, 9)  # <- so individual runs can be re-evaluated
i <- 1
for (e in c("n", "z", "p")) {
    for (d in c("n", "z", "p")) {
        cat(sprintf("\n\neta: %s || d: %s (%i / 9) \n", e, d, i))
        set.seed(seeds[i])
        args <- quant_gen_pars(e, d, q = 2)
        qg <- do.call(quant_gen, args)
        saveRDS(qg, sprintf("results/q2/%s-eta_%s-d.rds", e, d))
        i <- i + 1
    }
}
```


### Three traits

```{r, run_sims_q3, eval = FALSE, echo = TRUE}
# Takes ~3.5 hrs
set.seed(1713696743)
seeds <- sample.int(.Machine$integer.max, 9)  # <- so individual runs can be re-evaluated
i <- 1
for (e in c("n", "z", "p")) {
    for (d in c("n", "z", "p")) {
        cat(sprintf("\n\neta: %s || d: %s (%i / 9) \n", e, d, i))
        set.seed(seeds[i])
        args <- quant_gen_pars(e, d, q = 3)
        qg <- do.call(quant_gen, args)
        saveRDS(qg, sprintf("results/q3/%s-eta_%s-d.rds", e, d))
        i <- i + 1
    }
}
```


```{r jacobian_mats}
# -------------*
# Jacobian matrices to assess stability:
# -------------*
# Jacobian for one simulation rep:
one_jacobian <- function(N, V, call_) {
    other_args <- as.list(call_)[c("eta", "f", "g", "d", "add_var")]
    args_ <- c(list(N = N, V = V),
               other_args[c("f", "g", "d", "add_var")])
    args_$add_var <- args_$add_var[1:length(N)]  # it's assumed they're all the same
    args_$C <- matrix(other_args$eta, length(V[[1]]), length(V[[1]]))
    diag(args_$C) <- 1
    jacobian_mat <- do.call(sauron:::jacobian_cpp, args_)
    return(jacobian_mat)
}
# Same but for a `quant_gen` object containing multiple reps:
jacobians <- function(qg_obj) {
    jc_mats <- qg_obj %>%
        .[["nv"]] %>%
        filter(time == max(time)) %>%
        group_by(rep, spp) %>%
        summarize(N = N[[1]],
                  V = list(value)) %>%
        group_by(rep) %>%
        summarize(N = list(N),
                  V = list(V)) %>%
        ungroup() %>%
        mutate(jacobs = map2(N, V, ~ one_jacobian(.x, .y, qg_obj$call))) %>%
        .[["jacobs"]]
    return(jc_mats)
}
# Vector of primary eigenvalues for a `quant_gen` object containing multiple reps:
eigens <- function(qg_obj) map_dbl(jacobians(qg_obj),
                                   ~ Re(eigen(.x, only.values = TRUE, 
                                              symmetric = FALSE)$values[1]))
```


## Results

### Stability

For stability I'm computing the primary eigenvalue of the Jacobian matrix of
first derivatives.
The eigenvalue is hereafter referred to as $\lambda$.
I considered a state "stable" when $\lambda < 1$ and
"neutrally stable" when $\lambda = 1$.
For each scenario of $\eta$ and $d$ (each being negative, zero, or positive),
I calculated $\lambda$ for each of the 100 reps.
Below, the column `lambda` contains the range of $\lambda$ values among all reps.


#### Stability - 2 traits

```{r q2-stability}
# (Takes ~10 sec)
stab_df2 <- data_frame(eta = rep(1:3, each = 3), d = rep(1:3, 3)) %>% 
    mutate(lambda = map_chr(1:n(), 
                             function(i) {
                                 eigs_ <- sims2[[i]] %>% eigens()
                                 return(sprintf("(%.4g, %.4g)", min(eigs_), max(eigs_)))
                             }))
stab_df2 %>% 
    arrange(eta, d) %>% 
    mutate(eta = ifelse(duplicated(eta), 4, eta)) %>% 
    mutate_at(vars(eta, d), 
              function(x) factor(map_chr(x, ~ c("$-$", "$0$", "$+$", "")[.x]))) %>% 
    knitr::kable(align = c("l", "l", "r"))
```

#### Stability - 3 traits

```{r q3-stability}
# (Takes ~10 sec)
stab_df3 <- data_frame(eta = rep(1:3, each = 3), d = rep(1:3, 3)) %>% 
    mutate(lambda = map_chr(1:n(), 
                             function(i) {
                                 eigs_ <- sims3[[i]] %>% eigens()
                                 return(sprintf("(%.4g, %.4g)", min(eigs_), max(eigs_)))
                             }))
stab_df3 %>% 
    arrange(eta, d) %>% 
    mutate(eta = ifelse(duplicated(eta), 4, eta)) %>% 
    mutate_at(vars(eta, d), 
              function(x) factor(map_chr(x, ~ c("$-$", "$0$", "$+$", "")[.x]))) %>% 
    knitr::kable(align = c("l", "l", "r"))
```


### Coexistence

For each scenario of $\eta$ and $d$ (each being negative, zero, or positive),
I calculated the number of total species present at the final time point
for each of the 100 reps.
Below, the column `n_spp` contains the range of final species totals among all reps.

#### Coexistence - 2 traits

```{r q2-coexistence}
coex_df2 <- data_frame(eta = rep(1:3, each = 3), d = rep(1:3, 3)) %>% 
    mutate(n_spp = map_chr(1:n(),
                             function(i) {
                                 n_spp_ <- sims2[[i]]$nv %>% 
                                     filter(time == max(time)) %>%
                                     group_by(rep) %>%
                                     summarize(N = length(unique(spp))) %>%
                                     .[["N"]]
                                 return(sprintf("(%.4g, %.4g)", min(n_spp_), max(n_spp_)))
                             }))
coex_df2 %>% 
    arrange(eta, d) %>% 
    mutate(eta = ifelse(duplicated(eta), 4, eta)) %>% 
    mutate_at(vars(eta, d), 
              function(x) factor(map_chr(x, ~ c("$-$", "$0$", "$+$", "")[.x]))) %>% 
    knitr::kable(align = c("l", "l", "r"))
```

#### Coexistence - 3 traits

```{r q3-coexistence}
coex_df3 <- data_frame(eta = rep(1:3, each = 3), d = rep(1:3, 3)) %>% 
    mutate(n_spp = map_chr(1:n(),
                             function(i) {
                                 n_spp_ <- sims3[[i]]$nv %>% 
                                     filter(time == max(time)) %>%
                                     group_by(rep) %>%
                                     summarize(N = length(unique(spp))) %>%
                                     .[["N"]]
                                 return(sprintf("(%.4g, %.4g)", min(n_spp_), max(n_spp_)))
                             }))
coex_df3 %>% 
    arrange(eta, d) %>% 
    mutate(eta = ifelse(duplicated(eta), 4, eta)) %>% 
    mutate_at(vars(eta, d), 
              function(x) factor(map_chr(x, ~ c("$-$", "$0$", "$+$", "")[.x]))) %>% 
    knitr::kable(align = c("l", "l", "r"))
```


### Plots

#### Plots - 2 traits

```{r two-trait-plots}
plot2 <- map_dfr(1:length(sims2),
                  ~ sims2[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims2[[.x]]$call$eta, d = sims2[[.x]]$call$d)) %>% 
    # To make sure zeros get plotted first:
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = paste(c(0, sort(unique(x)[-2]))))) %>% 
    arrange(d, eta) %>% 
    # Now ordering factors normally:
    mutate_at(vars(eta, d), function(x) factor(x, levels = sort(unique(paste(x))))) %>% 
    # Plotting:
    ggplot(aes(T1, T2)) + #, size = T3)) +
    geom_point(aes(color = eta), shape = 16, alpha = 0.5, size = 3) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    NULL
plot2
```


### Plots - 3 traits

```{r three-traits-plots}
plot3 <- map_dfr(1:length(sims3),
                  ~ sims3[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    arrange(T3) %>%
    mutate_at(vars(eta, d), function(x) factor(x, levels = sort(unique(paste(x))))) %>%
    mutate(scenario = interaction(eta, d, sep = "_")) %>%
    ggplot(aes(T1, T2, size = T3)) +
    geom_point(aes(color = eta, alpha = scenario), shape = 16) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(size = 4))) +
    scale_alpha_manual(values = c(c(0.5, 0.25, 0.5), rep(c(0.5, 0.05, 0.01), 2)),
                       guide = FALSE) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    scale_size_continuous("Trait 3", breaks = -1:1) +
    NULL
plot3
# ggsave("~/Desktop/plot.png", plot3, width = 8, height = 3)
```


By taking a "slice" at T3 ~ 0, we can verify that it's a shell when $\eta = 0$ and a ring
when $\eta > 0$.

```{r three-traits-plots2}
# # Value of trait 3 to filter for:
# t3 <- sims3[[1]]$nv$value %>% 
#     signif(digits = 10) %>%
#     abs() %>%
#     unique()
# n_per <- 10

filter_unq <- function(..., precision = 1e-2) {
    V <- do.call(cbind, list(...))
    V <- split(V, row(V))
    sauron:::unq_spp_cpp(V, precision) == 1
}

q3 <- map_dfr(1:length(sims3),
        ~ sims3[[.x]]$nv %>%
            mutate(trait = factor(paste0("T", paste(trait)))) %>%
            spread("trait", "value") %>%
            mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    filter(T3 <= 0, eta >= 0) %>% 
    group_by(d) %>%
    filter(filter_unq(T1, T2, T3, precision = 5e-2)) %>%
    ungroup() %>%
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = sort(unique(x))))


library(akima)
library(rgl)


spline_interpolated <- interp(q3$T1, q3$T2, q3$T3,
                              nx = 200, ny = 200,
                              linear = FALSE, extrap = FALSE, jitter = 0)


x.si <- spline_interpolated$x
y.si <- spline_interpolated$y
z.si <- spline_interpolated$z

persp3d(x.si, y.si, z.si, col = "gray")


map_dfr(1:length(sims3),
        ~ sims3[[.x]]$nv %>%
            mutate(trait = factor(paste0("T", paste(trait)))) %>%
            spread("trait", "value") %>%
            mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    filter(T3 <= 0) %>% 
    # group_by(d) %>% 
    # filter(filter_unq(T1, T2, T3, precision = 1e-1)) %>%
    # ungroup() %>% 
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = sort(unique(x)))) %>%
    ggplot(aes(T1, T2, color = T3)) +
    geom_point(alpha = 0.5, shape = 16) +
    facet_wrap(~ d + eta, nrow = 2, labeller = label_both) +
    scale_color_continuous(high = "#132B43", low = "#56B1F7")

map_dfr(1:length(sims3),
        ~ sims3[[.x]]$nv %>%
            mutate(trait = factor(paste0("T", paste(trait)))) %>%
            spread("trait", "value") %>%
            mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    filter(eta == 0) %>% 
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = sort(unique(x)))) %>%
    group_by(d) %>% 
    filter(filter_unq(T1, T2, T3, precision = 2e-1)) %>%
    ungroup() %>% 
    ggplot(aes(T1, T2, size = T3)) +
    geom_point(alpha = 0.5, shape = 16) +
    facet_wrap(~ d, nrow = 1, labeller = label_both)
    
    
    
    # filter((d >= 0 & T3^2 < 0.01^2) | (d < 0 & T3^2 < 0.2^2), eta >= 0) %>% 
    # filter((d >= 0 & (T3 - t3)^2 < 0.01^2) | (d < 0 & (T3 - t3)^2 < 0.1^2)) %>%
    filter((T3 - t3)^2 < 0.01^2 | (T3 - (t3/2))^2 < 0.01^2 | (T3 - (0))^2 < 0.01^2) %>%
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = sort(unique(x)))) %>%
    group_by(eta, d) %>% 
    filter(1:n() %in% sample.int()) %>% 
    arrange(eta) %>%
    ggplot(aes(T1, T2, size = T3)) +
    geom_point(aes(color = eta), alpha = 0.5, shape = 16) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    NULL
```





## Summary

### 2 traits

| $\eta$  |  $d$   | Pattern                       | Coexistence |
|:-------:|:------:|:------------------------------|------------:|
| $-$     | $-$    | two alternative stable states | No          |
|         | 0      | two alternative stable states | Yes         |
|         | $+$    | two alternative stable states | Yes         |
| 0       | $-$    | neutrally stable ring         | No          |
|         | 0      | neutrally stable ring         | Yes         |
|         | $+$    | neutrally stable ring         | Yes         |
| $+$     | $-$    | two alternative stable states | No          |
|         | 0      | two alternative stable states | Yes         |
|         | $+$    | two alternative stable states | Yes         |

### 3 traits

| $\eta$  |  $d$   | Pattern                       | Coexistence |
|:-------:|:------:|:------------------------------|------------:|
| $-$     | $-$    | two alternative stable states | No          |
|         | 0      | two alternative stable states | Yes         |
|         | $+$    | two alternative stable states | Yes         |
| 0       | $-$    | neutrally stable "shell"      | No          |
|         | 0      | neutrally stable "shell"      | Yes         |
|         | $+$    | neutrally stable "shell"      | Yes         |
| $+$     | $-$    | neutrally stable ring         | No          |
|         | 0      | neutrally stable ring         | Yes         |
|         | $+$    | neutrally stable ring         | Yes         |

