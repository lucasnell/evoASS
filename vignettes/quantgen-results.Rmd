---
title: "Quantitative genetics results"
author: "Lucas A. Nell"
date: "01/03/2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quantitative genetics results}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png", 
  fig.width = 6,
  fig.height = 4,
  echo = TRUE,
  eval = TRUE
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
suppressPackageStartupMessages({
    library(tidyverse)
    library(sauron)
})
```


## Load saved simulation output

```{r get-sim-info}
# Function to get the relevant rds file for a given simulation scenario:
get_sim <- function(eta_sign, d_sign, q) {
    fn <- sprintf("results/quant_gen/q%i/eta=%s__d=%s.rds", q, eta_sign, d_sign)
    return(readRDS(fn))
}
# 2 traits:
sims2 <- map2(rep(1:3, each = 3), rep(1:3, 3), 
              function(e, d, .q) {
                  chrs <- -1:1
                  qg_ <- get_sim(chrs[e], chrs[d], .q)
                  qg_$nv <- qg_$nv %>% filter(time == max(time))
                  return(qg_)
              }, .q = 2)
# 3 traits:
sims3 <- map2(rep(1:3, each = 3), rep(1:3, 3), 
              function(e, d, .q) {
                  chrs <- -1:1
                  qg_ <- get_sim(chrs[e], chrs[d], .q)
                  qg_$nv <- qg_$nv %>% filter(time == max(time))
                  return(qg_)
              }, .q = 3)
```




## Results

### Stability

For stability I'm computing the primary eigenvalue of the Jacobian matrix of
first derivatives.
The eigenvalue is hereafter referred to as $\lambda$.
I considered a state "stable" when $\lambda < 1$ and
"neutrally stable" when $\lambda = 1$.
For each scenario of $\eta$ and $d$ (each being negative, zero, or positive),
I calculated $\lambda$ for each of the 100 reps.
In the tables below, the column $\lambda$ contains the range of $\lambda$ values
among all reps.


##### Stability functions:

```{r jacobian_mats}
# Jacobian for one simulation rep:
one_jacobian <- function(N, V, call_) {
    other_args <- c(as.list(call_)[c("eta", "d")],
                    with(formals(quant_gen), {
                        list(f = f, g = g, add_var = eval(add_var))
                        }))
    args_ <- c(list(N = N, V = V),
               other_args[c("f", "g", "d", "add_var")])
    args_$add_var <- args_$add_var[1:length(N)]  # it's assumed they're all the same
    args_$C <- matrix(other_args$eta, length(V[[1]]), length(V[[1]]))
    diag(args_$C) <- 1
    jacobian_mat <- do.call(sauron:::jacobian_cpp, args_)
    return(jacobian_mat)
}
# Same but for a `quant_gen` object containing multiple reps:
jacobians <- function(qg_obj) {
    jc_mats <- qg_obj$nv %>%
        filter(time == max(time)) %>%
        group_by(rep, spp) %>%
        summarize(N = N[[1]],
                  V = list(value)) %>%
        group_by(rep) %>%
        summarize(N = list(N),
                  V = list(V)) %>%
        ungroup() %>%
        mutate(jacobs = map2(N, V, ~ one_jacobian(.x, .y, qg_obj$call))) %>%
        .[["jacobs"]]
    return(jc_mats)
}
# Vector of primary eigenvalues for a `quant_gen` object containing multiple reps:
eigens <- function(qg_obj) map_dbl(jacobians(qg_obj),
                                   ~ Re(eigen(.x, only.values = TRUE, 
                                              symmetric = FALSE)$values[1]))
```


```{r make-kable-fxn, echo = FALSE}
make_kable <- function(COL, FUN, ...) {
    VARS <- "ZZZ"
    names(VARS) <- COL
    
    tibble(eta = rep(1:3, each = 3), d = rep(1:3, 3)) %>% 
        mutate(ZZZ = map_chr(1:n(), FUN, ...)) %>% 
        mutate(eta = ifelse(duplicated(eta), 4, eta)) %>% 
        mutate_at(vars(eta, d), 
                  function(x) factor(map_chr(x, ~ c("$-$", "$0$", "$+$", "")[.x]))) %>% 
        rename(`$\\eta$` = eta, `$d$` = d) %>% 
        rename(!!!VARS) %>% 
        knitr::kable(align = c("l", "l", "r"))
}
```


#### Stability - 2 traits:

```{r q2-stability, echo = FALSE}
get_eig <- function(i, sims_) {
    eigs_ <- sims_[[i]] %>% eigens()
    return(sprintf("(%.4g, %.4g)", min(eigs_), max(eigs_)))
}
make_kable("$\\lambda$", get_eig, sims_ = sims2)
```

#### Stability - 3 traits:

```{r q3-stability, echo = FALSE}
# (Takes ~10 sec)
make_kable("$\\lambda$", get_eig, sims_ = sims3)
```


### Coexistence

For each scenario of $\eta$ and $d$ (each being negative, zero, or positive),
I calculated the number of total species present at the final time point
for each of the 100 reps.
Below, the column "n_spp" contains the range of final species totals among all reps.

#### Coexistence - 2 traits

```{r q2-coexistence, echo = FALSE}
get_nspp <- function(i, sims_) {
    n_spp_ <- sims_[[i]]$nv %>% 
        filter(time == max(time)) %>%
        group_by(rep) %>%
        summarize(N = length(unique(spp))) %>%
        .[["N"]]
    return(sprintf("(%.4g, %.4g)", min(n_spp_), max(n_spp_)))
}

make_kable("n_spp", get_nspp, sims_ = sims2)
```

#### Coexistence - 3 traits

```{r q3-coexistence, echo = FALSE}
make_kable("n_spp", get_nspp, sims_ = sims3)
```


### Shapes

#### Shapes - 2 traits

```{r two-trait-plots, echo = FALSE, fig.height=3}
plot2 <- map_dfr(1:length(sims2),
                  ~ sims2[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims2[[.x]]$call$eta, d = sims2[[.x]]$call$d)) %>% 
    # To make sure zeros get plotted first:
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = paste(c(0, sort(unique(x)[-2]))))) %>% 
    arrange(d, eta) %>% 
    # Now ordering factors normally:
    mutate_at(vars(eta, d), function(x) factor(x, levels = sort(unique(paste(x))))) %>% 
    # Plotting:
    ggplot(aes(T1, T2)) +
    geom_point(aes(color = eta), shape = 16, alpha = 0.5, size = 3) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(expression(bold(eta)),
                       values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    NULL
plot2
# ggsave("~/Desktop/plot2.png", plot2, width = 6, height = 3)
```


### Shapes - 3 traits

```{r three-traits-plots, echo = FALSE, fig.height=3}
plot3 <- map_dfr(1:length(sims3),
                  ~ sims3[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    arrange(T3) %>%
    mutate_at(vars(eta, d), function(x) factor(x, levels = sort(unique(paste(x))))) %>%
    mutate(scenario = interaction(eta, d, sep = "_")) %>%
    ggplot(aes(T1, T2, size = T3)) +
    geom_point(aes(color = eta, alpha = scenario), shape = 16) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(expression(bold(eta)),
                       values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(size = 4))) +
    scale_alpha_manual(values = c(c(0.5, 0.25, 0.5), rep(c(0.5, 0.05, 0.01), 2)),
                       guide = FALSE) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    scale_size_continuous("Trait 3", breaks = -1:1) +
    NULL
plot3
# ggsave("~/Desktop/plot3.png", plot3, width = 6, height = 3)
```


By taking "slices" at varying values of trait 3, we can verify that it's a shell
when $\eta = 0$ and a ring when $\eta > 0$.
We can also see that when $\eta < 0$, both alternative stable points exist on the
neutrally stable shell (see blue points on panels labelled
"Trait 3: -1.17" and "Trait 3: 1.17").

```{r three-traits-plots2, echo = FALSE}
# Values of trait 3 to filter for:
t3 <- sims3[[1]]$nv$value %>%
    signif(digits = 10) %>% 
    abs() %>% 
    unique() %>% 
    `+`(seq(0.5, -1, -0.5)) %>% 
    map(~ .x * c(-1,1)) %>% 
    unlist() %>% 
    sort()
# Filter for a trait being near any one of a vector of thresholds (`f_vec`),
# with a precision as input
filter_trait <- function(trait, f_vec, prec = 0.01) {
    prec <- prec^2
    map_lgl(trait, function(x) any((x - f_vec)^2 < prec))
}
# Match trait values with one of a vector of thresholds
match_trait <- function(trait, f_vec, trait_name) {
    m_vec <- map_dbl(trait, function(x) {
        diff <- (x - f_vec)^2
        i <- which(diff == min(diff))
        return(f_vec[i])
    })
    m_vec <- factor(m_vec, levels = sort(f_vec), 
                  labels = sprintf("%s = %.3g", trait_name, f_vec))
    return(m_vec)
}

plot3b <- map_dfr(1:length(sims3),
                  ~ sims3[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    filter(filter_trait(T3, t3)) %>% 
    mutate(stage = match_trait(T3, t3, "Trait 3")) %>% 
    # Making factor levels weird, then ordering by eta, so that eta == 0 values
    # are plotted first (otherwise the other eta-valued points won't be visible):
    mutate_at(vars(eta, d), function(x) factor(paste(x),
                                               levels = sort(unique(x))[c(2, 1, 3)])) %>% 
    arrange(eta) %>% 
    # Now converting eta and d back to normal ordering so their legends are in
    # proper order:
    mutate_at(vars(eta, d), function(x) factor(x, levels = levels(x)[c(2, 1, 3)])) %>% 
    # Plotting:
    ggplot(aes(T1, T2, size = T3, color = eta)) +
    geom_point(alpha = 0.5, shape = 16, size = 3) +
    facet_wrap( ~ stage, nrow = 2) +
    scale_color_manual(expression(bold(eta)),
                       values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme(legend.position = "top", strip.text = element_text(size = 9)) +
    xlab("Trait 1") +
    ylab("Trait 2") +
    NULL
plot3b
# ggsave("~/Desktop/plot3b.png", plot3b, width = 6, height = 4)
```





## Summary

* 💕 = coexistence
* 👎 = no coexistence


### Summary - 2 traits:

| $\eta$  |  $d$   | Pattern                       |    |
|:-------:|:------:|:------------------------------|---:|
| $-$     | $-$    | two alternative stable states | 👎 |
|         | 0      | two alternative stable states | 💕 |
|         | $+$    | two alternative stable states | 💕 |
| 0       | $-$    | neutrally stable ring         | 👎 |
|         | 0      | neutrally stable ring         | 💕 |
|         | $+$    | neutrally stable ring         | 💕 |
| $+$     | $-$    | two alternative stable states | 👎 |
|         | 0      | two alternative stable states | 💕 |
|         | $+$    | two alternative stable states | 💕 |


### Summary - 3 traits:

| $\eta$  |  $d$   | Pattern                       |    |
|:-------:|:------:|:------------------------------|---:|
| $-$     | $-$    | two alternative stable states | 👎 |
|         | 0      | two alternative stable states | 💕 |
|         | $+$    | two alternative stable states | 💕 |
| 0       | $-$    | neutrally stable "shell"      | 👎 |
|         | 0      | neutrally stable "shell"      | 💕 |
|         | $+$    | neutrally stable "shell"      | 💕 |
| $+$     | $-$    | neutrally stable ring         | 👎 |
|         | 0      | neutrally stable ring         | 💕 |
|         | $+$    | neutrally stable ring         | 💕 |








## Looking at transient dynamics

When $d \le 0$, everything stays the same after time point 10,000.
When $d > 0$ , this happens at $8 \times 10^6$ for traits and $19.9 \times 10^6$
for abundances.


```{r check_equil, echo = FALSE, eval = FALSE}
# Are two sets of traits the same?
V_same <- function(Vs, precision) {
    V1 <- Vs[[1]]
    V2 <- Vs[[2]]
    if (length(V1) != length(V2)) return(FALSE)
    return(all((V1 - V2)^2 < precision^2))
}
# Are two sets of abundances the same?
N_same <- function(Ns, precision) {
    N1 <- Ns[[1]]
    N2 <- Ns[[2]]
    if (length(N1) != length(N2)) return(FALSE)
    return(all((N1 - N2)^2 < precision^2))
}
# Same but for a `quant_gen` object containing multiple reps, and checking
# whether a specified time point is different from the last one:
check_diff <- function(qg_obj, time1, precision = 1e-4) {
    time1 <- min(qg_obj$nv$time[qg_obj$nv$time > time1])
    time2 <- max(qg_obj$nv$time)
    # Filtered data frame:
    fdf <- qg_obj$nv %>%
        filter(time == time1 | time == time2) %>%
        arrange(rep, time, spp, trait) %>%
        group_by(rep, time, spp) %>%
        summarize(N = N[[1]],
                  V = list(value)) %>%
        group_by(rep, time) %>%
        summarize(N = list(N),
                  V = list(do.call(rbind, V))) %>%
        ungroup()
    
    fdf %>% 
        group_by(rep) %>% 
        summarize(V_s = V_same(V, precision),
                  N_s = N_same(N, precision)) %>% 
        summarize_at(vars(V_s, N_s), sum)
}


# Checking that no simulation scenarios deviate from what I mention above:
for (q in 2:3) {
    for (e in -1:1) {
        for (d in -1:1) {
            qg <- get_sim(e, d, q)
            # 19.9e6 + 1, then 20e6
            if (d > 0) {
                y <- unlist(check_diff(qg, 19.9e6))
                z <- unlist(check_diff(qg, 8e6))
                if (any(y != 100) || z[["V_s"]] != 100) {
                    cat(sprintf("\n-------------\neta = %.2g, d = %.2g\n", e, d))
                    print(y)
                    print(z)
                }
            } else {
                z <- unlist(check_diff(qg, 10e3))
                if (any(z != 100)) {
                    cat(sprintf("\n-------------\neta = %.2g, d = %.2g\n", e, d))
                    print(z)
                }
            }
        }
    }
}

# If you ever want to look at how N changes through time:
sim_df <- map2_dfr(rep(1:3, each = 3), rep(1:3, 3), 
                   function(e, d, .q) {
                       chrs <- -1:1
                       qg_ <- get_sim(chrs[e], chrs[d], .q)
                       return(mutate(qg_$nv, eta_d = sprintf("%i_%i", chrs[e], chrs[d])))
                   }, .q = 2) %>%
    select(eta_d, everything()) %>%
    mutate(eta_d = factor(eta_d))
sim_df %>%
    filter(rep == 1, trait == 1, eta_d == "-1_1") %>%
    ggplot(aes(time, N)) +
    geom_line(aes(group = spp)) +
    # facet_wrap(~ eta_d, nrow = 3) +
    NULL
```



