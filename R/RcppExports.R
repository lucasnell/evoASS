# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multiple repetitions of adaptive dynamics.
#'
#'
#' @noRd
#'
adapt_dyn_cpp <- function(n_reps, V0, N0, f, a0, C, r0, D, sigma_V0, sigma_N, sigma_V, max_t, min_N, mut_sd, mut_prob, show_progress, max_clones, save_every, n_threads) {
    .Call(`_sauron_adapt_dyn_cpp`, n_reps, V0, N0, f, a0, C, r0, D, sigma_V0, sigma_N, sigma_V, max_t, min_N, mut_sd, mut_prob, show_progress, max_clones, save_every, n_threads)
}

#' Derivative of fitness with respect to the trait divided by mean fitness.
#'
#' The function below calculates this selection strength for all traits
#' for all species.
#'
#' @noRd
#'
NULL

#' Partial derivative of species i traits at time t+1 with respect to
#' species i traits at time t.
#'
#'
#' @noRd
#'
NULL

#' Partial derivative of species i traits at time t+1 with respect to
#' species k traits at time t.
#'
#' @noRd
#'
#'
NULL

#' Partial derivative of species i traits at time t+1 with respect to
#' species i abundance at time t.
#'
#' @noRd
#'
#'
NULL

#' Partial derivative of species i traits at time t+1 with respect to
#' species k abundance at time t.
#'
#' @noRd
#'
#'
NULL

#' Partial derivative of species i abundance at time t+1 with respect to
#' species i traits at time t.
#'
#' @noRd
#'
#'
NULL

#' Partial derivative of species i abundance at time t+1 with respect to
#' species k traits at time t.
#'
#' @noRd
#'
#'
NULL

#' Partial derivative of species i abundance at time t+1 with respect to
#' species i abundance at time t.
#'
#' @noRd
#'
#'
NULL

#' Partial derivative of species i abundance at time t+1 with respect to
#' species k abundance at time t.
#'
#' @noRd
#'
#'
NULL

#' One repetition of quantitative genetics.
#'
#' Higher-up function(s) should handle the info put into `info`.
#'
#'
#' @noRd
#'
NULL

#' R-exported version of above, so it can be tested in R for accuracy.
#'
#' @noRd
#'
sel_str_cpp <- function(V, N, f, a0, C, r0, D) {
    .Call(`_sauron_sel_str_cpp`, V, N, f, a0, C, r0, D)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dVi_dVi_cpp <- function(i, V, Omega, C, f, a0, add_var) {
    .Call(`_sauron_dVi_dVi_cpp`, i, V, Omega, C, f, a0, add_var)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dVi_dVk_cpp <- function(i, k, N, V, D, a0, add_var) {
    .Call(`_sauron_dVi_dVk_cpp`, i, k, N, V, D, a0, add_var)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dVi_dNi_cpp <- function(i, V, a0, add_var) {
    .Call(`_sauron_dVi_dNi_cpp`, i, V, a0, add_var)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dVi_dNk_cpp <- function(i, k, V, D, a0, add_var) {
    .Call(`_sauron_dVi_dNk_cpp`, i, k, V, D, a0, add_var)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dNi_dVi_cpp <- function(i, V, N, f, a0, C, r0, D) {
    .Call(`_sauron_dNi_dVi_cpp`, i, V, N, f, a0, C, r0, D)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dNi_dVk_cpp <- function(i, k, V, N, f, a0, C, r0, D) {
    .Call(`_sauron_dNi_dVk_cpp`, i, k, V, N, f, a0, C, r0, D)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dNi_dNi_cpp <- function(i, V, N, f, a0, C, r0, D) {
    .Call(`_sauron_dNi_dNi_cpp`, i, V, N, f, a0, C, r0, D)
}

#' R-exported version of above, to be used in R for testing.
#'
#' NOTE: This does NOT account for step function to keep traits >= 0
#'
#' @noRd
#'
dNi_dNk_cpp <- function(i, k, V, N, f, a0, C, r0, D) {
    .Call(`_sauron_dNi_dNk_cpp`, i, k, V, N, f, a0, C, r0, D)
}

#' Calculate the Jacobian of first derivatives.
#'
#' Cell [i,j] contains the partial derivative of j with respect to i.
#'
#' NOTE: This DOES account for step function to keep traits >= 0
#'
#' @noRd
#'
jacobian_cpp <- function(V, N, f, a0, r0, D, C, add_var, evo_only) {
    .Call(`_sauron_jacobian_cpp`, V, N, f, a0, r0, D, C, add_var, evo_only)
}

#' Search for unique species in a matrix of species trait values.
#'
#' @noRd
#'
unq_spp_cpp <- function(V, precision) {
    .Call(`_sauron_unq_spp_cpp`, V, precision)
}

group_spp_cpp <- function(V, precision) {
    .Call(`_sauron_group_spp_cpp`, V, precision)
}

#' Multiple repetitions of quantitative genetics.
#'
#'
#' @noRd
#'
quant_gen_cpp <- function(n_reps, V0, Vp0, N0, f, a0, C, r0, D, add_var, sigma_V0, sigma_N, sigma_V, spp_gap_t, final_t, min_N, save_every, show_progress, n_threads) {
    .Call(`_sauron_quant_gen_cpp`, n_reps, V0, Vp0, N0, f, a0, C, r0, D, add_var, sigma_V0, sigma_N, sigma_V, spp_gap_t, final_t, min_N, save_every, show_progress, n_threads)
}

#' Normal distribution truncated above zero.
#'
#' From `http://web.michaelchughes.com/research/sampling-from-truncated-normal`
#'
#' @noRd
#'
trunc_rnorm_cpp <- function(N, mu, sigma) {
    .Call(`_sauron_trunc_rnorm_cpp`, N, mu, sigma)
}

trunc_rnorm_mu_cpp <- function(mu, sigma) {
    .Call(`_sauron_trunc_rnorm_mu_cpp`, mu, sigma)
}

trunc_rnorm_sigma_cpp <- function(mu, sigma) {
    .Call(`_sauron_trunc_rnorm_sigma_cpp`, mu, sigma)
}

trunc_rnorm_mu_sigma_cpp <- function(mu, sigma) {
    .Call(`_sauron_trunc_rnorm_mu_sigma_cpp`, mu, sigma)
}

F_t_cpp <- function(V, N, f, a0, C, r0, D) {
    .Call(`_sauron_F_t_cpp`, V, N, f, a0, C, r0, D)
}

F_it_cpp <- function(i, V, N, f, a0, C, r0, D) {
    .Call(`_sauron_F_it_cpp`, i, V, N, f, a0, C, r0, D)
}

using_openmp <- function() {
    .Call(`_sauron_using_openmp`)
}

