# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multiple repetitions of adaptive dynamics.
#'
#'
#' @noRd
#'
adapt_dyn_cpp <- function(n_reps, V0, N0, f, a0, eta, r0, d, max_t, min_N, mut_sd, mut_prob, show_progress, max_clones, save_every, n_cores) {
    .Call(`_sauron_adapt_dyn_cpp`, n_reps, V0, N0, f, a0, eta, r0, d, max_t, min_N, mut_sd, mut_prob, show_progress, max_clones, save_every, n_cores)
}

#' Derivative of fitness with respect to the trait divided by mean fitness.
#'
#' The function below calculates this selection strength for all traits
#' for all species.
#'
#' @noRd
#'
NULL

#' Partial derivative of species i traits at time t+1 with respect to species i traits
#' at time t.
#'
#'
#' @noRd
#'
NULL

#' Partial derivative of species i traits at time t+1 with respect to species k traits
#' at time t.
#'
#' @noRd
#'
#'
NULL

#' Search for unique species in a matrix of species trait values.
#'
#' @noRd
#'
NULL

#' One repetition of quantitative genetics.
#'
#' Higher-up function(s) should handle the info put into `info`.
#'
#'
#' @noRd
#'
NULL

#' R-exported version of above, so it can be tested in R for accuracy.
#'
#' @noRd
#'
sel_str_cpp <- function(V, N, f, a0, C, r0, d) {
    .Call(`_sauron_sel_str_cpp`, V, N, f, a0, C, r0, d)
}

#' R-exported version of above, to be used in R for testing.
#'
#' @noRd
#'
dVi_dVi_cpp <- function(i, V, Z, CCC, f, a0, add_var) {
    .Call(`_sauron_dVi_dVi_cpp`, i, V, Z, CCC, f, a0, add_var)
}

#' R-exported version of above, to be used in R for testing.
#'
#' @noRd
#'
dVi_dVk_cpp <- function(i, k, N, V, d, a0, add_var) {
    .Call(`_sauron_dVi_dVk_cpp`, i, k, N, V, d, a0, add_var)
}

#' Calculate the Jacobian of first derivatives.
#'
#' Cell [i,j] contains the partial derivative of j with respect to i.
#'
#' @noRd
#'
jacobian_cpp <- function(V, N, f, a0, d, C, add_var) {
    .Call(`_sauron_jacobian_cpp`, V, N, f, a0, d, C, add_var)
}

#' Same as above, but exported for use in R
#'
#' @noRd
#'
unq_spp_cpp <- function(V, precision) {
    .Call(`_sauron_unq_spp_cpp`, V, precision)
}

#' Multiple repetitions of quantitative genetics.
#'
#'
#' @noRd
#'
quant_gen_cpp <- function(n_reps, V0, N0, f, a0, eta, r0, d, add_var, perturb_sd, start_t, max_t, min_N, save_every, show_progress, n_cores) {
    .Call(`_sauron_quant_gen_cpp`, n_reps, V0, N0, f, a0, eta, r0, d, add_var, perturb_sd, start_t, max_t, min_N, save_every, show_progress, n_cores)
}

#' Normal distribution truncated above zero.
#'
#' From `http://web.michaelchughes.com/research/sampling-from-truncated-normal`
#'
#' @noRd
#'
trunc_rnorm_cpp <- function(N, mu, sigma) {
    .Call(`_sauron_trunc_rnorm_cpp`, N, mu, sigma)
}

#' Fitness at time t.
#'
#' @param V List of row vectors, each containing trait values at time t (1x2 vector)
#'     for a particular clone.
#' @param N Row vector of population abundances at time t.
#' @param f Effect of traits on growth rate.
#' @param a0 Base density dependence.
#' @param C Matrix containing non-additive effects of traits on growth rate.
#' @param r0 Starting growth rate.
#' @param d Changes how the focal line is affected by other lines' trait values.
#'     If `d < 0`, then increases in `V_j` (trait that reduces competition
#'     experienced by clone `j`) increases competition experienced by clone `i`,
#'     thereby giving conflicting coevolution.
#'     Conversely, if `d > 0`, then increases in `V_j` decrease competition
#'     experienced by clone `i`, leading to nonconflicting coevolution.
#'
#'
#' @export
#'
F_t_cpp <- function(V, N, f, a0, C, r0, d) {
    .Call(`_sauron_F_t_cpp`, V, N, f, a0, C, r0, d)
}

