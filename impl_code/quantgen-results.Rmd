---
title: "Quantitative genetics results"
author: "Lucas A. Nell"
date: "01/03/2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quantitative genetics results}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "png", 
  fig.width = 6,
  fig.height = 4,
  echo = TRUE,
  eval = TRUE
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 8L)
```
```{r source_Rprofile, echo = FALSE}
if (!isTRUE(getOption('knitr.in.progress'))) source(".Rprofile")
suppressPackageStartupMessages({
    library(tidyverse)
    library(sauron)
    library(cowplot)
})
```


## Load saved simulation output

```{r get-sim-info}
# Function to get the relevant rds file for a given simulation scenario:
get_sim <- function(eta_sign, d_sign, q) {
    fn <- sprintf("results/quant_gen/q%i/eta=%s__d=%s.rds", q, eta_sign, d_sign)
    return(readRDS(fn))
}
# 2 traits:
sims2 <- map2(rep(1:3, each = 3), rep(1:3, 3), 
              function(e, d, .q) {
                  chrs <- -1:1
                  qg_ <- get_sim(chrs[e], chrs[d], .q)
                  qg_$nv <- qg_$nv %>% filter(time == max(time))
                  return(qg_)
              }, .q = 2)
# 3 traits:
sims3 <- map2(rep(1:3, each = 3), rep(1:3, 3), 
              function(e, d, .q) {
                  chrs <- -1:1
                  qg_ <- get_sim(chrs[e], chrs[d], .q)
                  qg_$nv <- qg_$nv %>% filter(time == max(time))
                  return(qg_)
              }, .q = 3)
```




## Results

### Stability

For stability I'm computing the primary eigenvalue of the Jacobian matrix of
first derivatives.
The eigenvalue is hereafter referred to as $\lambda$.
I considered a state "stable" when $\lambda < 1$ and
"neutrally stable" when $\lambda = 1$.
For each scenario of $\eta$ and $d$ (each being negative, zero, or positive),
I calculated $\lambda$ for each of the 100 reps.
In the tables below, the column $\lambda$ contains the range of $\lambda$ values
among all reps.


##### Stability functions:

```{r jacobian_mats}
# Jacobian for one simulation rep:
one_jacobian <- function(N, V, call_) {
    other_args <- c(as.list(call_)[c("eta", "d")],
                    with(formals(quant_gen), {
                        list(f = f, g = g, add_var = eval(add_var))
                        }))
    args_ <- c(list(N = N, V = V),
               other_args[c("f", "g", "d", "add_var")])
    args_$add_var <- args_$add_var[1:length(N)]  # it's assumed they're all the same
    args_$C <- matrix(other_args$eta, length(V[[1]]), length(V[[1]]))
    diag(args_$C) <- 1
    jacobian_mat <- do.call(sauron:::jacobian_cpp, args_)
    return(jacobian_mat)
}
# Same but for a `quant_gen` object containing multiple reps:
jacobians <- function(qg_obj) {
    jc_mats <- qg_obj$nv %>%
        filter(time == max(time)) %>%
        group_by(rep, spp) %>%
        summarize(N = N[[1]],
                  V = list(value)) %>%
        group_by(rep) %>%
        summarize(N = list(N),
                  V = list(V)) %>%
        ungroup() %>%
        mutate(jacobs = map2(N, V, ~ one_jacobian(.x, .y, qg_obj$call))) %>%
        .[["jacobs"]]
    return(jc_mats)
}
# Vector of primary eigenvalues for a `quant_gen` object containing multiple reps:
eigens <- function(qg_obj) map_dbl(jacobians(qg_obj),
                                   ~ Re(eigen(.x, only.values = TRUE, 
                                              symmetric = FALSE)$values[1]))
```


```{r make-kable-fxn, echo = FALSE}
make_kable <- function(COL, FUN, ...) {
    VARS <- "ZZZ"
    names(VARS) <- COL
    
    tibble(eta = rep(1:3, each = 3), d = rep(1:3, 3)) %>% 
        mutate(ZZZ = map_chr(1:n(), FUN, ...)) %>% 
        mutate(eta = ifelse(duplicated(eta), 4, eta)) %>% 
        mutate_at(vars(eta, d), 
                  function(x) factor(map_chr(x, ~ c("$-$", "$0$", "$+$", "")[.x]))) %>% 
        rename(`$\\eta$` = eta, `$d$` = d) %>% 
        rename(!!!VARS) %>% 
        knitr::kable(align = c("l", "l", "r"))
}
```


#### Stability - 2 traits:

```{r q2-stability, echo = FALSE}
get_eig <- function(i, sims_) {
    eigs_ <- sims_[[i]] %>% eigens()
    return(sprintf("(%.4g, %.4g)", min(eigs_), max(eigs_)))
}
make_kable("$\\lambda$", get_eig, sims_ = sims2)
```

#### Stability - 3 traits:

```{r q3-stability, echo = FALSE}
# (Takes ~10 sec)
make_kable("$\\lambda$", get_eig, sims_ = sims3)
```


### Coexistence

For each scenario of $\eta$ and $d$ (each being negative, zero, or positive),
I calculated the number of total species present at the final time point
for each of the 100 reps.
Below, the column "n_spp" contains the range of final species totals among all reps.

#### Coexistence - 2 traits

```{r q2-coexistence, echo = FALSE}
get_nspp <- function(i, sims_) {
    n_spp_ <- sims_[[i]]$nv %>% 
        filter(time == max(time)) %>%
        group_by(rep) %>%
        summarize(N = length(unique(spp))) %>%
        .[["N"]]
    return(sprintf("(%.4g, %.4g)", min(n_spp_), max(n_spp_)))
}

make_kable("n_spp", get_nspp, sims_ = sims2)
```

#### Coexistence - 3 traits

```{r q3-coexistence, echo = FALSE}
make_kable("n_spp", get_nspp, sims_ = sims3)
```


### Shapes

#### Shapes - 2 traits

```{r two-trait-plots, echo = FALSE, fig.height=3}
plot2 <- map_dfr(1:length(sims2),
                  ~ sims2[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims2[[.x]]$call$eta, d = sims2[[.x]]$call$d)) %>% 
    # To make sure zeros get plotted first:
    mutate_at(vars(eta, d), function(x) factor(paste(x), levels = paste(c(0, sort(unique(x)[-2]))))) %>% 
    arrange(d, eta) %>% 
    # Now ordering factors normally:
    mutate_at(vars(eta, d), function(x) factor(x, levels = sort(unique(paste(x))))) %>% 
    # Plotting:
    ggplot(aes(T1, T2)) +
    geom_point(aes(color = eta), shape = 16, alpha = 0.5, size = 3) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(expression(bold(eta)),
                       values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    NULL
plot2
# ggsave("~/Desktop/plot2.png", plot2, width = 6, height = 3)
```


### Shapes - 3 traits

```{r three-traits-plots, echo = FALSE, fig.height=3}
plot3 <- map_dfr(1:length(sims3),
                  ~ sims3[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    arrange(T3) %>%
    mutate_at(vars(eta, d), function(x) factor(x, levels = sort(unique(paste(x))))) %>%
    mutate(scenario = interaction(eta, d, sep = "_")) %>%
    ggplot(aes(T1, T2, size = T3)) +
    geom_point(aes(color = eta, alpha = scenario), shape = 16) +
    facet_wrap(~ d, nrow = 1, labeller = label_both) +
    scale_color_manual(expression(bold(eta)),
                       values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(size = 4))) +
    scale_alpha_manual(values = c(c(0.5, 0.25, 0.5), rep(c(0.5, 0.05, 0.01), 2)),
                       guide = FALSE) +
    theme(legend.position = "top") +
    xlab("Trait 1") +
    ylab("Trait 2") +
    scale_size_continuous("Trait 3", breaks = -1:1) +
    NULL
plot3
# ggsave("~/Desktop/plot3.png", plot3, width = 6, height = 3)
```


By taking "slices" at varying values of trait 3, we can verify that it's a shell
when $\eta = 0$ and a ring when $\eta > 0$.
We can also see that when $\eta < 0$, both alternative stable points exist on the
neutrally stable shell (see blue points on panels labelled
"Trait 3: -1.17" and "Trait 3: 1.17").

```{r three-traits-plots2, echo = FALSE}
# Values of trait 3 to filter for:
t3 <- sims3[[1]]$nv$value %>%
    signif(digits = 10) %>% 
    abs() %>% 
    unique() %>% 
    `+`(seq(0.5, -1, -0.5)) %>% 
    map(~ .x * c(-1,1)) %>% 
    unlist() %>% 
    sort()
# Filter for a trait being near any one of a vector of thresholds (`f_vec`),
# with a precision as input
filter_trait <- function(trait, f_vec, prec = 0.01) {
    prec <- prec^2
    map_lgl(trait, function(x) any((x - f_vec)^2 < prec))
}
# Match trait values with one of a vector of thresholds
match_trait <- function(trait, f_vec, trait_name) {
    m_vec <- map_dbl(trait, function(x) {
        diff <- (x - f_vec)^2
        i <- which(diff == min(diff))
        return(f_vec[i])
    })
    m_vec <- factor(m_vec, levels = sort(f_vec), 
                  labels = sprintf("%s = %.3g", trait_name, f_vec))
    return(m_vec)
}

plot3b <- map_dfr(1:length(sims3),
                  ~ sims3[[.x]]$nv %>%
                      mutate(trait = factor(paste0("T", paste(trait)))) %>%
                      spread("trait", "value") %>%
                      mutate(eta = sims3[[.x]]$call$eta, d = sims3[[.x]]$call$d)) %>% 
    filter(filter_trait(T3, t3)) %>% 
    mutate(stage = match_trait(T3, t3, "Trait 3")) %>% 
    # Making factor levels weird, then ordering by eta, so that eta == 0 values
    # are plotted first (otherwise the other eta-valued points won't be visible):
    mutate_at(vars(eta, d), function(x) factor(paste(x),
                                               levels = sort(unique(x))[c(2, 1, 3)])) %>% 
    arrange(eta) %>% 
    # Now converting eta and d back to normal ordering so their legends are in
    # proper order:
    mutate_at(vars(eta, d), function(x) factor(x, levels = levels(x)[c(2, 1, 3)])) %>% 
    # Plotting:
    ggplot(aes(T1, T2, size = T3, color = eta)) +
    geom_point(alpha = 0.5, shape = 16, size = 3) +
    facet_wrap( ~ stage, nrow = 2) +
    scale_color_manual(expression(bold(eta)),
                       values = c("dodgerblue3", "goldenrod1", "black"),
                       guide = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme(legend.position = "top", strip.text = element_text(size = 9)) +
    xlab("Trait 1") +
    ylab("Trait 2") +
    NULL
plot3b
# ggsave("~/Desktop/plot3b.png", plot3b, width = 6, height = 4)
```





## Summary


### Summary - 2 traits:

| $\eta$  |  $d$   | Pattern                       | Coexistence |
|:-------:|:------:|:------------------------------|------------:|
| $-$     | $-$    | two alternative stable states | No          |
|         | 0      | two alternative stable states | Yes         |
|         | $+$    | two alternative stable states | Yes         |
| 0       | $-$    | neutrally stable ring         | No          |
|         | 0      | neutrally stable ring         | Yes         |
|         | $+$    | neutrally stable ring         | Yes         |
| $+$     | $-$    | two alternative stable states | No          |
|         | 0      | two alternative stable states | Yes         |
|         | $+$    | two alternative stable states | Yes         |


### Summary - 3 traits:

| $\eta$  |  $d$   | Pattern                       | Coexistence |
|:-------:|:------:|:------------------------------|------------:|
| $-$     | $-$    | two alternative stable states | No          |
|         | 0      | two alternative stable states | Yes         |
|         | $+$    | two alternative stable states | Yes         |
| 0       | $-$    | neutrally stable "shell"      | No          |
|         | 0      | neutrally stable "shell"      | Yes         |
|         | $+$    | neutrally stable "shell"      | Yes         |
| $+$     | $-$    | neutrally stable ring         | No          |
|         | 0      | neutrally stable ring         | Yes         |
|         | $+$    | neutrally stable ring         | Yes         |








## Looking at transient dynamics

When $d \le 0$, everything stays the same after time point 10,001.
When $d > 0$ , this happens at $8 \times 10^6 + 1$ for traits and $19.9 \times 10^6 + 1$
for abundances.
For all scenarios, the final set of lineages is reached very early:
$t =$ 10,001 for $d \le 0$ and 
$t =$ 100,001 for $d > 0$.


```{r check_equil, echo = FALSE, eval = FALSE}
# Are two sets of traits the same?
V_same <- function(Vs, precision) {
    V1 <- Vs[[1]]
    V2 <- Vs[[2]]
    if (length(V1) != length(V2)) return(FALSE)
    return(all((V1 - V2)^2 < precision^2))
}
# Are two sets of abundances the same?
N_same <- function(Ns, precision) {
    N1 <- Ns[[1]]
    N2 <- Ns[[2]]
    if (length(N1) != length(N2)) return(FALSE)
    return(all((N1 - N2)^2 < precision^2))
}
# Same but for a `quant_gen` object containing multiple reps, and checking
# whether a specified time point is different from the last one:
check_diff <- function(qg_obj, time1, precision = 1e-4) {
    time1 <- min(qg_obj$nv$time[qg_obj$nv$time > time1])
    time2 <- max(qg_obj$nv$time)
    # Filtered data frame:
    fdf <- qg_obj$nv %>%
        filter(time == time1 | time == time2) %>%
        arrange(rep, time, spp, trait) %>%
        group_by(rep, time, spp) %>%
        summarize(N = N[[1]],
                  V = list(value)) %>%
        group_by(rep, time) %>%
        summarize(N = list(N),
                  V = list(do.call(rbind, V))) %>%
        ungroup()
    
    fdf %>% 
        group_by(rep) %>% 
        summarize(V_s = V_same(V, precision),
                  N_s = N_same(N, precision)) %>% 
        summarize_at(vars(V_s, N_s), sum)
}


# Checking that no simulation scenarios deviate from what I mention above:
for (q in 2:3) {
    for (e in -1:1) {
        for (d in -1:1) {
            qg <- get_sim(e, d, q)
            # 19.9e6 + 1, then 20e6
            if (d > 0) {
                y <- unlist(check_diff(qg, 19.9e6))
                z <- unlist(check_diff(qg, 8e6))
                if (any(y != 100) || z[["V_s"]] != 100) {
                    cat(sprintf("\n-------------\neta = %.2g, d = %.2g\n", e, d))
                    print(y)
                    print(z)
                }
            } else {
                z <- unlist(check_diff(qg, 10e3))
                if (any(z != 100)) {
                    cat(sprintf("\n-------------\neta = %.2g, d = %.2g\n", e, d))
                    print(z)
                }
            }
        }
    }
}

# Data frames of traits and N through time:
sim_df2 <- map2_dfr(rep(-1:1, each = 3), rep(-1:1, 3), 
                   function(e, d, .q) {
                       qg_ <- get_sim(e, d, .q)
                       return(mutate(qg_$nv, eta_d = sprintf("%i_%i", e, d)))
                   }, .q = 2) %>%
    select(eta_d, everything()) %>%
    mutate(eta_d = factor(eta_d), q = 2)
sim_df3 <- map2_dfr(rep(-1:1, each = 3), rep(-1:1, 3), 
                   function(e, d, .q) {
                       qg_ <- get_sim(e, d, .q)
                       return(mutate(qg_$nv, eta_d = sprintf("%i_%i", e, d)))
                   }, .q = 3) %>%
    select(eta_d, everything()) %>%
    mutate(eta_d = factor(eta_d), q = 3)


# When each one reaches final set of lineages:
sim_df2 %>%
    group_by(eta_d, rep, time) %>% 
    summarize(n_spp = n() / q[[1]], q = q[[1]]) %>% 
    group_by(eta_d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(n_spp_equil = which(n_spp == final_spp)[1]) %>% 
    group_by(eta_d) %>% 
    summarize(min = min(n_spp_equil), max = max(n_spp_equil))
sim_df3 %>%
    group_by(eta_d, rep, time) %>% 
    summarize(n_spp = n() / q[[1]], q = q[[1]]) %>% 
    group_by(eta_d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(n_spp_equil = which(n_spp == final_spp)[1]) %>% 
    group_by(eta_d) %>% 
    summarize(min = min(n_spp_equil), max = max(n_spp_equil))
sim_df2 %>% 
    distinct(eta_d, time) %>% 
    group_by(eta_d) %>% 
    summarize(x = sort(time)[2])
sim_df3 %>% 
    distinct(eta_d, time) %>% 
    group_by(eta_d) %>% 
    summarize(x = sort(time)[2])


# # If you ever want to look at how N changes through time:
# sim_df2 %>%
#     filter(rep == 1, trait == 1, eta_d == "-1_1") %>%
#     ggplot(aes(time, N)) +
#     geom_line(aes(group = spp)) +
#     # facet_wrap(~ eta_d, nrow = 3) +
#     NULL
```



By looking at finer time scales, I found that,
for all scenarios, the final set of lineages is reached even earlier:
$t =$ 3,201.


```{r tran_dyn_finer_res, echo = FALSE, eval = FALSE}
# ----------
# Now looking at better resolution as to when final species sets are made:
# ----------
seeds <- tibble(q = rep(2:3, each = 9),
                eta = rep(rep(-1:1, each = 3), 2),
                d = rep(rep(-1:1, 3), 2),
                value = numeric(18))
set.seed(2028111205)
seeds$value[seeds$q==2] <- sample.int(.Machine$integer.max, 9)
set.seed(1713696743)
seeds$value[seeds$q==3] <- sample.int(.Machine$integer.max, 9)

# Takes ~20 min
sim_df <- pmap_dfr(list(rep(2:3, each = 9),
                        rep(rep(-1:1, each = 3), 2),
                        rep(rep(-1:1, 3), 2)),
                    function(.q, .e, .d) {
                        seed <- seeds %>%
                            filter(q == .q, eta == .e, d == .d) %>%
                            .[["value"]]
                        args_ <- quant_gen_args(.e, .d, .q)
                        if (.d > 0) {
                            args_$max_t <- 1e5L
                            args_$save_every <- 1e3L
                        } else {
                            args_$max_t <- 1e4L
                            args_$save_every <- 1e2L
                        }
                        args_$show_progress <- FALSE
                        set.seed(seed)
                        qg_ <- do.call(quant_gen, args_)
                        nv <- mutate(qg_$nv, eta = args_$eta, d = args_$d, q = .q,
                                      trait = paste(trait))
                        return(nv)
                    }) %>%
    select(eta, d, everything()) %>%
    mutate_at(vars(eta, d, q, trait), factor)


sim_df %>%
    group_by(q, eta, d, rep, time) %>% 
    summarize(n_spp = n() / as.integer(paste(q[[1]]))) %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(n_spp_equil = which(n_spp == final_spp)[1],
              t_n_spp_equil = time[n_spp_equil]) %>% 
    group_by(q, eta, d) %>% 
    summarize(min = min(n_spp_equil), max = max(n_spp_equil), 
              max_t = max(t_n_spp_equil)) %>% 
    ungroup() %>% 
    filter(max_t == max(max_t))
```




```{r tran_dyn_short, echo = FALSE, eval = FALSE}
seeds <- tibble(q = rep(2:3, each = 9),
                eta = rep(rep(-1:1, each = 3), 2),
                d = rep(rep(-1:1, 3), 2),
                value = numeric(18))
set.seed(2028111205)
seeds$value[seeds$q==2] <- sample.int(.Machine$integer.max, 9)
set.seed(1713696743)
seeds$value[seeds$q==3] <- sample.int(.Machine$integer.max, 9)

# Takes ~8 min
sim_df <- pmap_dfr(list(rep(2:3, each = 9),
                        rep(rep(-1:1, each = 3), 2),
                        rep(rep(-1:1, 3), 2)),
                    function(.q, .e, .d) {
                        seed <- seeds %>%
                            filter(q == .q, eta == .e, d == .d) %>%
                            .[["value"]]
                        args_ <- quant_gen_args(.e, .d, .q)
                        args_$max_t <- 5000L
                        args_$save_every <- 10L
                        args_$show_progress <- FALSE
                        set.seed(seed)
                        qg_ <- do.call(quant_gen, args_)
                        nv <- mutate(qg_$nv, eta = args_$eta, d = args_$d, q = .q,
                                      trait = paste(trait))
                        cat(sprintf("eta = %.2g | d = %.2g\n", .e, .d))
                        return(nv)
                    }) %>%
    select(eta, d, everything()) %>%
    mutate_at(vars(eta, d, q, trait), factor)

# sim_df %>%
#     filter(q == 2, rep == 1, time < 1000) %>%
#     ggplot(aes(time, N)) +
#     geom_line(aes(group = spp), alpha = 0.5) +
#     facet_wrap(~ eta + d, nrow = 3, scales = "free", labeller = label_both) +
#     NULL

max_times <- sim_df %>%
    group_by(q, eta, d, rep, time) %>% 
    summarize(n_spp = n() / as.integer(paste(q[[1]]))) %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(n_spp_equil = which(n_spp == final_spp)[1],
              t_n_spp_equil = time[n_spp_equil]) %>% 
    group_by(q, eta, d) %>% 
    summarize(min = min(n_spp_equil), max = max(n_spp_equil), 
              max_t = max(t_n_spp_equil)) %>% 
    ungroup() %>% 
    identity()

write_csv(max_times, "results/quant_gen/max_times.csv")
```





```{r tran_dyn_shortest}
max_times <- read_csv("results/quant_gen/max_times.csv", col_types = "iddiii")

seeds <- tibble(q = rep(2:3, each = 9),
                eta = rep(rep(-1:1, each = 3), 2),
                d = rep(rep(-1:1, 3), 2),
                value = integer(18))
set.seed(2028111205)
seeds$value[seeds$q==2] <- sample.int(.Machine$integer.max, 9)
set.seed(1713696743)
seeds$value[seeds$q==3] <- sample.int(.Machine$integer.max, 9)

# # Takes ~4 min
# sim_df <- pmap_dfr(list(rep(2:3, each = 9),
#                         rep(rep(-1:1, each = 3), 2),
#                         rep(rep(-1:1, 3), 2)),
#                     function(.q, .e, .d) {
#                         seed <- seeds %>%
#                             filter(q == .q, eta == .e, d == .d) %>%
#                             .[["value"]]
#                         max_t <- max_times %>% 
#                             filter(q == .q, 
#                                    sign(eta) == sign(.e),
#                                    sign(d) == sign(.d)) %>%
#                             .[["max_t"]]
#                         args_ <- quant_gen_args(.e, .d, .q)
#                         args_$max_t <- max_t - 1L
#                         args_$save_every <- 5L
#                         args_$show_progress <- FALSE
#                         if (max_t < 100) args_$save_every <- 1L
#                         set.seed(seed)
#                         qg_ <- do.call(quant_gen, args_)
#                         nv <- mutate(qg_$nv, eta = args_$eta, d = args_$d, q = .q,
#                                       trait = paste(trait))
#                         cat(sprintf("eta = %.2g | d = %.2g\n", .e, .d))
#                         return(nv)
#                     }) %>%
#     select(eta, d, everything()) %>%
#     mutate_at(vars(eta, d, q, trait), factor) %>%
#     select(q, everything()) %>% 
#     mutate_at(vars(q, rep), ~ as.integer(paste(.))) %>% 
#     mutate_at(vars(eta, d), ~ as.numeric(paste(.)))
# saveRDS(sim_df, "results/quant_gen/short_sims.rds")

sim_df <- readRDS("results/quant_gen/short_sims.rds")
```


```{r short_sim}

max_times <- sim_df %>%
    group_by(q, eta, d, rep, time) %>% 
    summarize(n_spp = n() / q[[1]]) %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(final_spp = n_spp[time == max(time)]) %>% 
    summarize(max_t = time[which(n_spp == final_spp)[1]]) %>% 
    ungroup()

changing_spp_sims <- sim_df %>% 
    group_by(q, eta, d, rep) %>% 
    mutate(still_changing = time <= 
               max_times$max_t[max_times$q == q[1] & max_times$eta == eta[1] &
                                   max_times$d == d[1] & max_times$rep == rep[1]] |
               time <= 5) %>% 
    ungroup() %>% 
    filter(still_changing) %>% 
    select(-still_changing)


changing_spp_sims %>% 
    filter(q == 2, rep == 1, eta == 0, d > 0) %>% 
    group_by(time) %>% 
    summarize(n_spp = n() %/% 2) %>% 
    ungroup()

# sim_df %>%
changing_spp_sims %>% 
    filter(q == 2, rep == 1) %>%
    ggplot(aes(time, N)) +
    geom_vline(data = max_times %>% filter(q == 2, rep == 1),
               aes(xintercept = max_t), linetype = 2) +
    geom_line(aes(group = spp), alpha = 0.5) +
    facet_wrap(~ eta + d, nrow = 3, scales = "free", labeller = label_both) +
    NULL


# sim_df %>% 
#     filter(q == 2, rep == 1) %>%
#     group_by(q, eta, d, rep, time) %>% 
#     mutate(n_spp = n() %/% q) %>% 
#     ungroup()




# set.seed(798424537)
# plot_reps <- list(q2 = sort(sample.int(100, 6)),
#                   q3 = sort(sample.int(100, 6)))
# I chose two from each:
plot_reps <- list(q2 = c(33, 76), q3 = c(9, 71))
plot_df <- sim_df %>% filter(rep %in% c(plot_reps, recursive = TRUE))

one_plot <- function(.eta, .d, .q, do_legend = FALSE) {
    plot_reps_ <- plot_reps[[paste0("q", .q)]]
    df_ <- plot_df %>% 
        filter(q == .q, sign(eta) == sign(.eta), sign(d) == sign(.d), 
               rep %in% plot_reps_)
    if (max(df_$time) < 50) {
        x_breaks <- c(0, 10, 20)
    } else if (max(df_$time) < 2000) {
        x_breaks <- c(0, 500, 1e3)
    } else {
        x_breaks <- c(0, 1000, 2000)
    }
    y_max <- ifelse(.q == 2, 3.616895, 4.999777)
    max_times_ <- max_times %>%
        filter(q == .q, sign(eta) == sign(.eta), sign(d) == sign(.d), 
               rep %in% plot_reps_)
    real_eta <- max_times_$eta[1]
    real_d <- max_times_$d[1]
    p <- df_ %>%
        ggplot(aes(time, value)) +
        geom_vline(data = max_times_, aes(xintercept = max_t), linetype = 2) +
        geom_line(aes(group = interaction(spp, trait), color = trait), size = 0.25) +
        scale_color_viridis_d("Trait:", alpha = 0.35, end = 0.9,
                              guide = guide_legend(override.aes = list(alpha = 1, 
                                                                       size = 1))) +
        facet_wrap(~ rep, nrow = 2) +
        theme(strip.background = element_blank(),
              strip.text = element_blank(),
              axis.text = element_text(size = 8),
              axis.title = element_blank()) +
        scale_y_continuous(breaks = c(-2, 0, 2), limits = c(-1,1) * y_max) +
        scale_x_continuous(breaks = x_breaks)
    if (do_legend) {
        p <- p + theme(legend.position = "top", legend.justification = "center")
    } else {
        p <- p + theme(legend.position = "none")
    }
    return(p)
}


lab_common <- ggplot() +
    theme_nothing() +
    scale_x_continuous(limits = 0:1) +
    scale_y_continuous(limits = 0:1)
top_labs <- lab_common +
    geom_text(aes(x = seq(1, 5, 2)/6, y = 0.5,
                  label = sprintf("italic(d) == %.2g", c(-0.1, 0, 1e-4))),
              hjust = 0.5, vjust = 0.5, parse = TRUE, size = 5)
right_labs <- lab_common +
    geom_text(aes(y = seq(1, 5, 2)/6, x = 0.5,
                  label = sprintf("eta == %.2f", c(0.1, 0, -0.1))),
              hjust = 0.5, vjust = 0.5, angle = 270, parse = TRUE, size = 5)
bot_labs <- lab_common +
    geom_text(aes(x = 0.5, y = 0.5, label = "Time"),
              hjust = 0.5, vjust = 0.5, size = 6)
left_labs <- lab_common +
    geom_text(aes(x = 0.5, y = 0.5, label = "Trait value"),
              hjust = 0.5, vjust = 0.5, angle = 90, size = 6)


main_plots2 <- plot_grid(plotlist = map2(rep(-1:1, each=3), rep(-1:1, 3), one_plot,
                                          .q = 2),
                          align = "hv", nrow = 3, labels = "AUTO",
                         hjust = 0)
legend2 <- get_legend(one_plot(-1, -1, 2, TRUE))
main_plots3 <- plot_grid(plotlist = map2(rep(-1:1, each=3), rep(-1:1, 3), one_plot, 
                                          .q = 3),
                            align = "hv", nrow = 3, labels = "AUTO")
legend3 <- get_legend(one_plot(-1, -1, 3, TRUE))


trans_plots2 <- plot_grid(NULL, legend2, NULL,
                          NULL, top_labs, NULL,
                          left_labs, main_plots2, right_labs,
                          NULL, bot_labs, NULL,
                          ncol = 3, rel_widths = c(0.05, 1, 0.05), 
                          rel_heights = c(0.05, 0.05, 1, 0.05))
trans_plots3 <- plot_grid(NULL, legend3, NULL,
                          NULL, top_labs, NULL,
                          left_labs, main_plots3, right_labs,
                          NULL, bot_labs, NULL,
                          ncol = 3, rel_widths = c(0.05, 1, 0.05), 
                          rel_heights = c(0.05, 0.05, 1, 0.05))

ggsave("figures/transient_dynamics_q2.pdf", trans_plots2, width = 6.5, height = 9)
ggsave("figures/transient_dynamics_q3.pdf", trans_plots3, width = 6.5, height = 9)
```

